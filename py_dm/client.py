###
### Generated by QuakeC -> Python translator
### Id: qc2python.py,v 1.5 2001/02/05 21:15:44 barryp Exp 
###
from qwpython.qwsv import engine, Vector
from qwpython.qcsupport import qc

import defs
import random
import combat
import subs
import world
import player
import weapons
import triggers

#  prototypes
modelindex_eyes = 0
modelindex_player = 0
# 
# =============================================================================
# 
# 				LEVEL CHANGING / INTERMISSION
# 
# =============================================================================
# 
nextmap = None
intermission_running = 0
intermission_exittime = 0
# QUAKED info_intermission (1 0.5 0.5) (-16 -16 -16) (16 16 16)
# This is the camera point for the intermission.
# Use mangle instead of angle, so you can set pitch or roll as well as yaw.  'pitch roll yaw'
# 

def info_intermission(*qwp_extra):
    qc.self.angles = qc.self.mangle #  so C can get at it
    

def SetChangeParms(*qwp_extra):
    if qc.self.health <= 0:
        SetNewParms()
        return 
        
    #  remove items
    qc.self.items -= qc.self.items & (defs.IT_KEY1 | defs.IT_KEY2 | defs.IT_INVISIBILITY | defs.IT_INVULNERABILITY | defs.IT_SUIT | defs.IT_QUAD)
    #  cap super health
    if qc.self.health > 100:
        qc.self.health = 100
    if qc.self.health < 50:
        qc.self.health = 50
    qc.parm1 = qc.self.items
    qc.parm2 = qc.self.health
    qc.parm3 = qc.self.armorvalue
    if qc.self.ammo_shells < 25:
        qc.parm4 = 25
    else:
        qc.parm4 = qc.self.ammo_shells
    qc.parm5 = qc.self.ammo_nails
    qc.parm6 = qc.self.ammo_rockets
    qc.parm7 = qc.self.ammo_cells
    qc.parm8 = qc.self.weapon
    qc.parm9 = qc.self.armortype * 100
    

def SetNewParms(*qwp_extra):
    qc.parm1 = defs.IT_SHOTGUN | defs.IT_AXE
    qc.parm2 = 100
    qc.parm3 = 0
    qc.parm4 = 25
    qc.parm5 = 0
    qc.parm6 = 0
    qc.parm7 = 0
    qc.parm8 = 1
    qc.parm9 = 0
    

def DecodeLevelParms(*qwp_extra):
    if qc.serverflags:
        if qc.world.model == 'maps/start.bsp':
            SetNewParms() #  take away all stuff on starting new episode
        
    qc.self.items = qc.parm1
    qc.self.health = qc.parm2
    qc.self.armorvalue = qc.parm3
    qc.self.ammo_shells = qc.parm4
    qc.self.ammo_nails = qc.parm5
    qc.self.ammo_rockets = qc.parm6
    qc.self.ammo_cells = qc.parm7
    qc.self.weapon = qc.parm8
    qc.self.armortype = qc.parm9 * 0.01
    
# 
# ============
# FindIntermission
# 
# Returns the entity to view from
# ============
# 

def FindIntermission(*qwp_extra):
    spot = engine.world
    cyc = 0
    #  look for info_intermission first
    spot = qc.find(qc.world, 'classname', 'info_intermission')
    if spot:
        #  pick a random one
        cyc = random.random() * 4
        while cyc > 1:
            spot = qc.find(spot, 'classname', 'info_intermission')
            if not spot:
                spot = qc.find(spot, 'classname', 'info_intermission')
            cyc -= 1
            
        return spot
        
    #  then look for the start position
    spot = qc.find(qc.world, 'classname', 'info_player_start')
    if spot:
        return spot
    qc.objerror('FindIntermission: no spot')
    

def GotoNextMap(*qwp_extra):
    newmap = None
    # ZOID: 12-13-96, samelevel is overloaded, only 1 works for same level
    if engine.cvar('samelevel') == 1: #  if samelevel is set, stay on same level
        engine.changelevel(qc.mapname)
    else:
        #  configurable map lists, see if the current map exists as a
        #  serverinfo/localinfo var
        newmap = qc.world.infokey(qc.mapname)
        if newmap != None:
            engine.changelevel(newmap)
        else:
            engine.changelevel(nextmap)
        
    
# 
# ============
# IntermissionThink
# 
# When the player presses attack or jump, change to the next level
# ============
# 

def IntermissionThink(*qwp_extra):
    if qc.time < intermission_exittime:
        return 
    if not qc.self.button0 and not qc.self.button1 and not qc.self.button2:
        return 
    GotoNextMap()
    
# 
# ============
# execute_changelevel
# 
# The global "nextmap" has been set previously.
# Take the players to the intermission spot
# ============
# 

def execute_changelevel(*qwp_extra):
    global intermission_running
    global intermission_exittime
    pos = engine.world
    intermission_running = 1
    #  enforce a wait time before allowing changelevel
    intermission_exittime = qc.time + 5
    pos = FindIntermission()
    #  play intermission music
    qc.WriteByte(defs.MSG_ALL, defs.SVC_CDTRACK)
    qc.WriteByte(defs.MSG_ALL, 3)
    qc.WriteByte(defs.MSG_ALL, defs.SVC_INTERMISSION)
    qc.WriteCoord(defs.MSG_ALL, pos.origin.x)
    qc.WriteCoord(defs.MSG_ALL, pos.origin.y)
    qc.WriteCoord(defs.MSG_ALL, pos.origin.z)
    qc.WriteAngle(defs.MSG_ALL, pos.mangle.x)
    qc.WriteAngle(defs.MSG_ALL, pos.mangle.y)
    qc.WriteAngle(defs.MSG_ALL, pos.mangle.z)
    qc.other = qc.find(qc.world, 'classname', 'player')
    while qc.other != qc.world:
        qc.other.takedamage = defs.DAMAGE_NO
        qc.other.solid = defs.SOLID_NOT
        qc.other.movetype = defs.MOVETYPE_NONE
        qc.other.modelindex = 0
        qc.other = qc.find(qc.other, 'classname', 'player')
        
    

def changelevel_touch(*qwp_extra):
    global nextmap
    pos = engine.world
    if qc.other.classname != 'player':
        return 
    #  if "noexit" is set, blow up the player trying to leave
    # ZOID, 12-13-96, noexit isn't supported in QW.  Overload samelevel
    #       if ((cvar("noexit") == 1) || ((cvar("noexit") == 2) && (mapname != "start")))
    if (engine.cvar('samelevel') == 2) or ((engine.cvar('samelevel') == 3) and (qc.mapname != 'start')):
        combat.T_Damage(qc.other, qc.self, qc.self, 50000)
        return 
        
    engine.bprint(defs.PRINT_HIGH, qc.other.netname)
    engine.bprint(defs.PRINT_HIGH, ' exited the level\012')
    nextmap = qc.self.map
    subs.SUB_UseTargets()
    qc.self.touch = subs.SUB_Null
    #  we can't move people right now, because touch functions are called
    #  in the middle of C movement code, so set a think time to do it
    qc.self.think = execute_changelevel
    qc.self.nextthink = qc.time + 0.1
    
# QUAKED trigger_changelevel (0.5 0.5 0.5) ? NO_INTERMISSION
# When the player touches this, he gets sent to the map listed in the "map" variable.  Unless the NO_INTERMISSION flag is set, the view will go to the info_intermission spot and display stats.
# 

def trigger_changelevel(*qwp_extra):
    if not qc.self.map:
        qc.objerror("chagnelevel trigger doesn't have map")
    subs.InitTrigger()
    qc.self.touch = changelevel_touch
    
# 
# =============================================================================
# 
# 				PLAYER GAME EDGE FUNCTIONS
# 
# =============================================================================
# 
#  called by ClientKill and DeadThink

def respawn(*qwp_extra):
    #  make a copy of the dead body for appearances sake
    world.CopyToBodyQue(qc.self)
    #  set default spawn parms
    SetNewParms()
    #  respawn              
    PutClientInServer()
    
# 
# ============
# ClientKill
# 
# Player entered the suicide command
# ============
# 

def ClientKill(*qwp_extra):
    engine.bprint(defs.PRINT_MEDIUM, qc.self.netname)
    engine.bprint(defs.PRINT_MEDIUM, ' suicides\012')
    player.set_suicide_frame()
    qc.self.modelindex = modelindex_player
    qc.self.logfrag(qc.self)
    qc.self.frags -= 2 #  extra penalty
    respawn()
    

def CheckSpawnPoint(v, *qwp_extra):
    return defs.FALSE
    
# 
# ============
# SelectSpawnPoint
# 
# Returns the entity to spawn at
# ============
# 

def SelectSpawnPoint(*qwp_extra):
    spot = engine.world
    newspot = engine.world
    thing = engine.world
    numspots = 0
    totalspots = 0
    rnum = 0
    pcount = 0
    rs = 0
    spots = engine.world
    numspots = 0
    totalspots = 0
    #  testinfo_player_start is only found in regioned levels
    spot = qc.find(qc.world, 'classname', 'testplayerstart')
    if spot:
        return spot
    #  choose a info_player_deathmatch point
    #  ok, find all spots that don't have players nearby
    spots = qc.world
    spot = qc.find(qc.world, 'classname', 'info_player_deathmatch')
    while spot:
        totalspots += 1
        thing = qc.findradius(spot.origin, 84)
        pcount = 0
        while thing:
            if thing.classname == 'player':
                pcount += 1
            thing = thing.chain
            
        if pcount == 0:
            spot.goalentity = spots
            spots = spot
            numspots += 1
            
        #  Get the next spot in the chain
        spot = qc.find(spot, 'classname', 'info_player_deathmatch')
        
    totalspots -= 1
    if not numspots:
        #  ack, they are all full, just pick one at random
        # 		bprint (PRINT_HIGH, "Ackk! All spots are full. Selecting random spawn spot\n");
        totalspots = round((random.random() * totalspots))
        spot = qc.find(qc.world, 'classname', 'info_player_deathmatch')
        while totalspots > 0:
            totalspots -= 1
            spot = qc.find(spot, 'classname', 'info_player_deathmatch')
            
        return spot
        
    #  We now have the number of spots available on the map in numspots
    #  Generate a random number between 1 and numspots
    numspots -= 1
    numspots = round((random.random() * numspots))
    spot = spots
    while numspots > 0:
        spot = spot.goalentity
        numspots -= 1
        
    return spot
    
# 
# ===========
# ValidateUser
# 
# 
# ============
# 

def ValidateUser(e, *qwp_extra):
    pass
# 
# ===========
# PutClientInServer
# 
# called each time a player enters a new level
# ============
# 

def PutClientInServer(*qwp_extra):
    global modelindex_eyes
    global modelindex_player
    spot = engine.world
    s = None
    qc.self.classname = 'player'
    qc.self.health = 100
    qc.self.takedamage = defs.DAMAGE_AIM
    qc.self.solid = defs.SOLID_SLIDEBOX
    qc.self.movetype = defs.MOVETYPE_WALK
    qc.self.show_hostile = 0
    qc.self.max_health = 100
    qc.self.flags = defs.FL_CLIENT
    qc.self.air_finished = qc.time + 12
    qc.self.dmg = 2 #  initial water damage
    qc.self.super_damage_finished = 0
    qc.self.radsuit_finished = 0
    qc.self.invisible_finished = 0
    qc.self.invincible_finished = 0
    qc.self.effects = 0
    qc.self.invincible_time = 0
    DecodeLevelParms()
    weapons.W_SetCurrentAmmo()
    qc.self.attack_finished = qc.time
    qc.self.th_pain = player.player_pain
    qc.self.th_die = player.PlayerDie
    qc.self.deadflag = defs.DEAD_NO
    #  paustime is set by teleporters to keep the player from moving a while
    qc.self.pausetime = 0
    spot = SelectSpawnPoint()
    qc.self.origin = spot.origin + Vector(0, 0, 1)
    qc.self.angles = spot.angles
    qc.self.fixangle = defs.TRUE #  turn this way immediately
    #  oh, this is a hack!
    qc.self.setmodel('progs/eyes.mdl')
    modelindex_eyes = qc.self.modelindex
    qc.self.setmodel('progs/player.mdl')
    modelindex_player = qc.self.modelindex
    qc.setsize(qc.self, defs.VEC_HULL_MIN, defs.VEC_HULL_MAX)
    qc.self.view_ofs = Vector(0, 0, 22)
    #  Mod - Xian (May.20.97)
    #  Bug where player would have velocity from their last kill
    qc.self.velocity = Vector(0, 0, 0)
    player.player_stand1()
    qc.makevectors(qc.self.angles)
    triggers.spawn_tfog(qc.self.origin + qc.v_forward * 20)
    triggers.spawn_tdeath(qc.self.origin, qc.self)
    #  Set Rocket Jump Modifiers
    if qc.stof(qc.world.infokey('rj')) != 0:
        defs.rj = qc.stof(qc.world.infokey('rj'))
        
    if defs.deathmatch == 4:
        qc.self.ammo_shells = 0
        if qc.stof(qc.world.infokey('axe')) == 0:
            qc.self.ammo_nails = 255
            qc.self.ammo_shells = 255
            qc.self.ammo_rockets = 255
            qc.self.ammo_cells = 255
            qc.self.items |= defs.IT_NAILGUN
            qc.self.items |= defs.IT_SUPER_NAILGUN
            qc.self.items |= defs.IT_SUPER_SHOTGUN
            qc.self.items |= defs.IT_ROCKET_LAUNCHER
            # 		self.items = self.items | IT_GRENADE_LAUNCHER;
            qc.self.items |= defs.IT_LIGHTNING
            
        qc.self.items = qc.self.items - (qc.self.items & (defs.IT_ARMOR1 | defs.IT_ARMOR2 | defs.IT_ARMOR3)) + defs.IT_ARMOR3
        qc.self.armorvalue = 200
        qc.self.armortype = 0.8
        qc.self.health = 250
        qc.self.items |= defs.IT_INVULNERABILITY
        qc.self.invincible_time = 1
        qc.self.invincible_finished = qc.time + 3
        
    if defs.deathmatch == 5:
        qc.self.ammo_nails = 80
        qc.self.ammo_shells = 30
        qc.self.ammo_rockets = 10
        qc.self.ammo_cells = 30
        qc.self.items |= defs.IT_NAILGUN
        qc.self.items |= defs.IT_SUPER_NAILGUN
        qc.self.items |= defs.IT_SUPER_SHOTGUN
        qc.self.items |= defs.IT_ROCKET_LAUNCHER
        qc.self.items |= defs.IT_GRENADE_LAUNCHER
        qc.self.items |= defs.IT_LIGHTNING
        qc.self.items = qc.self.items - (qc.self.items & (defs.IT_ARMOR1 | defs.IT_ARMOR2 | defs.IT_ARMOR3)) + defs.IT_ARMOR3
        qc.self.armorvalue = 200
        qc.self.armortype = 0.8
        qc.self.health = 200
        qc.self.items |= defs.IT_INVULNERABILITY
        qc.self.invincible_time = 1
        qc.self.invincible_finished = qc.time + 3
        
    
# 
# =============================================================================
# 
# 				QUAKED FUNCTIONS
# 
# =============================================================================
# 
# QUAKED info_player_start (1 0 0) (-16 -16 -24) (16 16 24)
# The normal starting point for a level.
# 

def info_player_start(*qwp_extra):
    pass
# QUAKED info_player_start2 (1 0 0) (-16 -16 -24) (16 16 24)
# Only used on start map for the return point from an episode.
# 

def info_player_start2(*qwp_extra):
    pass
# QUAKED info_player_deathmatch (1 0 1) (-16 -16 -24) (16 16 24)
# potential spawning position for deathmatch games
# 

def info_player_deathmatch(*qwp_extra):
    pass
# QUAKED info_player_coop (1 0 1) (-16 -16 -24) (16 16 24)
# potential spawning position for coop games
# 

def info_player_coop(*qwp_extra):
    pass
# 
# ===============================================================================
# 
# RULES
# 
# ===============================================================================
# 
# 
# go to the next level for deathmatch
# 

def NextLevel(*qwp_extra):
    global nextmap
    o = engine.world
    newmap = None
    if nextmap != None:
        return  #  already done
    if qc.mapname == 'start':
        if not engine.cvar('registered'):
            qc.mapname = 'e1m1'
            
        elif not (qc.serverflags & 1):
            qc.mapname = 'e1m1'
            qc.serverflags |= 1
            
        elif not (qc.serverflags & 2):
            qc.mapname = 'e2m1'
            qc.serverflags |= 2
            
        elif not (qc.serverflags & 4):
            qc.mapname = 'e3m1'
            qc.serverflags |= 4
            
        elif not (qc.serverflags & 8):
            qc.mapname = 'e4m1'
            qc.serverflags -= 7
            
        o = qc.spawn()
        o.map = qc.mapname
        
    else:
        #  find a trigger changelevel
        o = qc.find(qc.world, 'classname', 'trigger_changelevel')
        if not o or qc.mapname == 'start':
            #  go back to same map if no trigger_changelevel
            o = qc.spawn()
            o.map = qc.mapname
            
        
    nextmap = o.map
    if o.nextthink < qc.time:
        o.think = execute_changelevel
        o.nextthink = qc.time + 0.1
        
    
# 
# ============
# CheckRules
# 
# Exit deathmatch games upon conditions
# ============
# 

def CheckRules(*qwp_extra):
    if defs.timelimit and qc.time >= defs.timelimit:
        NextLevel()
    if defs.fraglimit and qc.self.frags >= defs.fraglimit:
        NextLevel()
    
# ============================================================================

def PlayerDeathThink(*qwp_extra):
    old_self = engine.world
    forward = 0
    if (qc.self.flags & defs.FL_ONGROUND):
        forward = qc.self.velocity.length()
        forward -= 20
        if forward <= 0:
            qc.self.velocity = Vector(0, 0, 0)
        else:
            qc.self.velocity = forward * qc.self.velocity.normalize()
        
    #  wait for all buttons released
    if qc.self.deadflag == defs.DEAD_DEAD:
        if qc.self.button2 or qc.self.button1 or qc.self.button0:
            return 
        qc.self.deadflag = defs.DEAD_RESPAWNABLE
        return 
        
    #  wait for any button down
    if not qc.self.button2 and not qc.self.button1 and not qc.self.button0:
        return 
    qc.self.button0 = 0
    qc.self.button1 = 0
    qc.self.button2 = 0
    respawn()
    

def PlayerJump(*qwp_extra):
    start = Vector(0, 0, 0)
    end = Vector(0, 0, 0)
    if qc.self.flags & defs.FL_WATERJUMP:
        return 
    if qc.self.waterlevel >= 2:
        #  play swiming sound
        if qc.self.swim_flag < qc.time:
            qc.self.swim_flag = qc.time + 1
            if random.random() < 0.5:
                qc.self.sound(defs.CHAN_BODY, 'misc/water1.wav', 1, defs.ATTN_NORM)
            else:
                qc.self.sound(defs.CHAN_BODY, 'misc/water2.wav', 1, defs.ATTN_NORM)
            
        return 
        
    if not (qc.self.flags & defs.FL_ONGROUND):
        return 
    if not (qc.self.flags & defs.FL_JUMPRELEASED):
        return  #  don't pogo stick
    qc.self.flags -= qc.self.flags & defs.FL_JUMPRELEASED
    qc.self.button2 = 0
    #  player jumping sound
    qc.self.sound(defs.CHAN_BODY, 'player/plyrjmp8.wav', 1, defs.ATTN_NORM)
    
# 
# ===========
# WaterMove
# 
# ============
# 

def WaterMove(*qwp_extra):
    # dprint (ftos(self.waterlevel));
    if qc.self.movetype == defs.MOVETYPE_NOCLIP:
        return 
    if qc.self.health < 0:
        return 
    if qc.self.waterlevel != 3:
        if qc.self.air_finished < qc.time:
            qc.self.sound(defs.CHAN_VOICE, 'player/gasp2.wav', 1, defs.ATTN_NORM)
        elif qc.self.air_finished < qc.time + 9:
            qc.self.sound(defs.CHAN_VOICE, 'player/gasp1.wav', 1, defs.ATTN_NORM)
        qc.self.air_finished = qc.time + 12
        qc.self.dmg = 2
        
    elif qc.self.air_finished < qc.time:
        #  drown!
        if qc.self.pain_finished < qc.time:
            qc.self.dmg += 2
            if qc.self.dmg > 15:
                qc.self.dmg = 10
            combat.T_Damage(qc.self, qc.world, qc.world, qc.self.dmg)
            qc.self.pain_finished = qc.time + 1
            
        
    if not qc.self.waterlevel:
        if qc.self.flags & defs.FL_INWATER:
            #  play leave water sound
            qc.self.sound(defs.CHAN_BODY, 'misc/outwater.wav', 1, defs.ATTN_NORM)
            qc.self.flags -= defs.FL_INWATER
            
        return 
        
    if qc.self.watertype == defs.CONTENT_LAVA:
        #  do damage
        if qc.self.dmgtime < qc.time:
            if qc.self.radsuit_finished > qc.time:
                qc.self.dmgtime = qc.time + 1
            else:
                qc.self.dmgtime = qc.time + 0.2
            combat.T_Damage(qc.self, qc.world, qc.world, 10 * qc.self.waterlevel)
            
        
    elif qc.self.watertype == defs.CONTENT_SLIME:
        #  do damage
        if qc.self.dmgtime < qc.time and qc.self.radsuit_finished < qc.time:
            qc.self.dmgtime = qc.time + 1
            combat.T_Damage(qc.self, qc.world, qc.world, 4 * qc.self.waterlevel)
            
        
    if not (qc.self.flags & defs.FL_INWATER):
        #  player enter water sound
        if qc.self.watertype == defs.CONTENT_LAVA:
            qc.self.sound(defs.CHAN_BODY, 'player/inlava.wav', 1, defs.ATTN_NORM)
        if qc.self.watertype == defs.CONTENT_WATER:
            qc.self.sound(defs.CHAN_BODY, 'player/inh2o.wav', 1, defs.ATTN_NORM)
        if qc.self.watertype == defs.CONTENT_SLIME:
            qc.self.sound(defs.CHAN_BODY, 'player/slimbrn2.wav', 1, defs.ATTN_NORM)
        qc.self.flags += defs.FL_INWATER
        qc.self.dmgtime = 0
        
    

def CheckWaterJump(*qwp_extra):
    start = Vector(0, 0, 0)
    end = Vector(0, 0, 0)
    #  check for a jump-out-of-water
    qc.makevectors(qc.self.angles)
    start = qc.self.origin
    start %= Vector(None, None, start.z + 8)
    qc.v_forward %= Vector(None, None, 0)
    qc.v_forward.normalize()
    end = start + qc.v_forward * 24
    qc.traceline(start, end, defs.TRUE, qc.self)
    if qc.trace_fraction < 1:
        #  solid at waist
        start %= Vector(None, None, start.z + qc.self.maxs.z - 8)
        end = start + qc.v_forward * 24
        qc.self.movedir = qc.trace_plane_normal * -50
        qc.traceline(start, end, defs.TRUE, qc.self)
        if qc.trace_fraction == 1:
            #  open at eye level
            qc.self.flags |= defs.FL_WATERJUMP
            qc.self.velocity %= Vector(None, None, 225)
            qc.self.flags -= qc.self.flags & defs.FL_JUMPRELEASED
            qc.self.teleport_time = qc.time + 2 #  safety net
            return 
            
        
    
# 
# ================
# PlayerPreThink
# 
# Called every frame before physics are run
# ================
# 

def PlayerPreThink(*qwp_extra):
    mspeed = 0
    aspeed = 0
    r = 0
    if intermission_running:
        IntermissionThink() #  otherwise a button could be missed between
        return  #  the think tics
        
    if qc.self.view_ofs == Vector(0, 0, 0):
        return  #  intermission or finale
    qc.makevectors(qc.self.v_angle) #  is this still used
    qc.self.deathtype = None
    CheckRules()
    WaterMove()
    # 
    # 	if (self.waterlevel == 2)
    # 		CheckWaterJump ();
    # 
    if qc.self.deadflag >= defs.DEAD_DEAD:
        PlayerDeathThink()
        return 
        
    if qc.self.deadflag == defs.DEAD_DYING:
        return  #  dying, so do nothing
    if qc.self.button2:
        PlayerJump()
        
    else:
        qc.self.flags |= defs.FL_JUMPRELEASED
    #  teleporters can force a non-moving pause time        
    if qc.time < qc.self.pausetime:
        qc.self.velocity = Vector(0, 0, 0)
    if qc.time > qc.self.attack_finished and qc.self.currentammo == 0 and qc.self.weapon != defs.IT_AXE:
        qc.self.weapon = weapons.W_BestWeapon()
        weapons.W_SetCurrentAmmo()
        
    
# 
# ================
# CheckPowerups
# 
# Check for turning off powerups
# ================
# 

def CheckPowerups(*qwp_extra):
    if qc.self.health <= 0:
        return 
    #  invisibility
    if qc.self.invisible_finished:
        #  sound and screen flash when items starts to run out
        if qc.self.invisible_sound < qc.time:
            qc.self.sound(defs.CHAN_AUTO, 'items/inv3.wav', 0.5, defs.ATTN_IDLE)
            qc.self.invisible_sound = qc.time + ((random.random() * 3) + 1)
            
        if qc.self.invisible_finished < qc.time + 3:
            if qc.self.invisible_time == 1:
                qc.self.sprint(defs.PRINT_HIGH, 'Ring of Shadows magic is fading\012')
                qc.self.stuffcmd('bf\012')
                qc.self.sound(defs.CHAN_AUTO, 'items/inv2.wav', 1, defs.ATTN_NORM)
                qc.self.invisible_time = qc.time + 1
                
            if qc.self.invisible_time < qc.time:
                qc.self.invisible_time = qc.time + 1
                qc.self.stuffcmd('bf\012')
                
            
        if qc.self.invisible_finished < qc.time:
            #  just stopped
            qc.self.items -= defs.IT_INVISIBILITY
            qc.self.invisible_finished = 0
            qc.self.invisible_time = 0
            
        #  use the eyes
        qc.self.frame = 0
        qc.self.modelindex = modelindex_eyes
        
    else:
        qc.self.modelindex = modelindex_player #  don't use eyes
    #  invincibility
    if qc.self.invincible_finished:
        #  sound and screen flash when items starts to run out
        if qc.self.invincible_finished < qc.time + 3:
            if qc.self.invincible_time == 1:
                qc.self.sprint(defs.PRINT_HIGH, 'Protection is almost burned out\012')
                qc.self.stuffcmd('bf\012')
                qc.self.sound(defs.CHAN_AUTO, 'items/protect2.wav', 1, defs.ATTN_NORM)
                qc.self.invincible_time = qc.time + 1
                
            if qc.self.invincible_time < qc.time:
                qc.self.invincible_time = qc.time + 1
                qc.self.stuffcmd('bf\012')
                
            
        if qc.self.invincible_finished < qc.time:
            #  just stopped
            qc.self.items -= defs.IT_INVULNERABILITY
            qc.self.invincible_time = 0
            qc.self.invincible_finished = 0
            
        if qc.self.invincible_finished > qc.time:
            qc.self.effects |= defs.EF_DIMLIGHT
            qc.self.effects |= defs.EF_RED
            
        else:
            qc.self.effects -= qc.self.effects & defs.EF_DIMLIGHT
            qc.self.effects -= qc.self.effects & defs.EF_RED
            
        
    #  super damage
    if qc.self.super_damage_finished:
        #  sound and screen flash when items starts to run out
        if qc.self.super_damage_finished < qc.time + 3:
            if qc.self.super_time == 1:
                if defs.deathmatch == 4:
                    qc.self.sprint(defs.PRINT_HIGH, 'OctaPower is wearing off\012')
                else:
                    qc.self.sprint(defs.PRINT_HIGH, 'Quad Damage is wearing off\012')
                qc.self.stuffcmd('bf\012')
                qc.self.sound(defs.CHAN_AUTO, 'items/damage2.wav', 1, defs.ATTN_NORM)
                qc.self.super_time = qc.time + 1
                
            if qc.self.super_time < qc.time:
                qc.self.super_time = qc.time + 1
                qc.self.stuffcmd('bf\012')
                
            
        if qc.self.super_damage_finished < qc.time:
            #  just stopped
            qc.self.items -= defs.IT_QUAD
            if defs.deathmatch == 4:
                qc.self.ammo_cells = 255
                qc.self.armorvalue = 1
                qc.self.armortype = 0.8
                qc.self.health = 100
                
            qc.self.super_damage_finished = 0
            qc.self.super_time = 0
            
        if qc.self.super_damage_finished > qc.time:
            qc.self.effects |= defs.EF_DIMLIGHT
            qc.self.effects |= defs.EF_BLUE
            
        else:
            qc.self.effects -= qc.self.effects & defs.EF_DIMLIGHT
            qc.self.effects -= qc.self.effects & defs.EF_BLUE
            
        
    #  suit 
    if qc.self.radsuit_finished:
        qc.self.air_finished = qc.time + 12 #  don't drown
        #  sound and screen flash when items starts to run out
        if qc.self.radsuit_finished < qc.time + 3:
            if qc.self.rad_time == 1:
                qc.self.sprint(defs.PRINT_HIGH, 'Air supply in Biosuit expiring\012')
                qc.self.stuffcmd('bf\012')
                qc.self.sound(defs.CHAN_AUTO, 'items/suit2.wav', 1, defs.ATTN_NORM)
                qc.self.rad_time = qc.time + 1
                
            if qc.self.rad_time < qc.time:
                qc.self.rad_time = qc.time + 1
                qc.self.stuffcmd('bf\012')
                
            
        if qc.self.radsuit_finished < qc.time:
            #  just stopped
            qc.self.items -= defs.IT_SUIT
            qc.self.rad_time = 0
            qc.self.radsuit_finished = 0
            
        
    
# 
# ================
# PlayerPostThink
# 
# Called every frame after physics are run
# ================
# 

def PlayerPostThink(*qwp_extra):
    mspeed = 0
    aspeed = 0
    r = 0
    # dprint ("post think\n");
    if qc.self.view_ofs == Vector(0, 0, 0):
        return  #  intermission or finale
    if qc.self.deadflag:
        return 
    #  check to see if player landed and play landing sound 
    if (qc.self.jump_flag < -300) and (qc.self.flags & defs.FL_ONGROUND):
        if qc.self.watertype == defs.CONTENT_WATER:
            qc.self.sound(defs.CHAN_BODY, 'player/h2ojump.wav', 1, defs.ATTN_NORM)
        elif qc.self.jump_flag < -650:
            qc.self.deathtype = 'falling'
            combat.T_Damage(qc.self, qc.world, qc.world, 5)
            qc.self.sound(defs.CHAN_VOICE, 'player/land2.wav', 1, defs.ATTN_NORM)
            
        else:
            qc.self.sound(defs.CHAN_VOICE, 'player/land.wav', 1, defs.ATTN_NORM)
        
    qc.self.jump_flag = qc.self.velocity.z
    CheckPowerups()
    weapons.W_WeaponFrame()
    
# 
# ===========
# ClientConnect
# 
# called when a player connects to a server
# ============
# 

def ClientConnect(*qwp_extra):
    engine.bprint(defs.PRINT_HIGH, qc.self.netname)
    engine.bprint(defs.PRINT_HIGH, ' entered the game\012')
    #  a client connecting during an intermission can cause problems
    if intermission_running:
        GotoNextMap()
    
# 
# ===========
# ClientDisconnect
# 
# called when a player disconnects from a server
# ============
# 

def ClientDisconnect(*qwp_extra):
    #  let everyone else know
    engine.bprint(defs.PRINT_HIGH, qc.self.netname)
    engine.bprint(defs.PRINT_HIGH, ' left the game with ')
    engine.bprint(defs.PRINT_HIGH, str(qc.self.frags))
    engine.bprint(defs.PRINT_HIGH, ' frags\012')
    qc.self.sound(defs.CHAN_BODY, 'player/tornoff2.wav', 1, defs.ATTN_NONE)
    player.set_suicide_frame()
    
# 
# ===========
# ClientObituary
# 
# called when a player dies
# ============
# 

def ClientObituary(targ, attacker, *qwp_extra):
    rnum = 0
    deathstring = None
    deathstring2 = None
    s = None
    attackerteam = None
    targteam = None
    rnum = random.random()
    # ZOID 12-13-96: self.team doesn't work in QW.  Use keys
    attackerteam = attacker.infokey('team')
    targteam = targ.infokey('team')
    if targ.classname == 'player':
        if defs.deathmatch > 3:
            if targ.deathtype == 'selfwater':
                engine.bprint(defs.PRINT_MEDIUM, targ.netname)
                engine.bprint(defs.PRINT_MEDIUM, ' electrocutes himself.\012 ')
                targ.frags -= 1
                return 
                
            
        if attacker.classname == 'teledeath':
            engine.bprint(defs.PRINT_MEDIUM, targ.netname)
            engine.bprint(defs.PRINT_MEDIUM, ' was telefragged by ')
            engine.bprint(defs.PRINT_MEDIUM, attacker.owner.netname)
            engine.bprint(defs.PRINT_MEDIUM, '\012')
            attacker.owner.logfrag(targ)
            attacker.owner.frags += 1
            return 
            
        if attacker.classname == 'teledeath2':
            engine.bprint(defs.PRINT_MEDIUM, "Satan's power deflects ")
            engine.bprint(defs.PRINT_MEDIUM, targ.netname)
            engine.bprint(defs.PRINT_MEDIUM, "'s telefrag\012")
            targ.frags -= 1
            targ.logfrag(targ)
            return 
            
        #  double 666 telefrag (can happen often in deathmatch 4)
        if attacker.classname == 'teledeath3':
            engine.bprint(defs.PRINT_MEDIUM, targ.netname)
            engine.bprint(defs.PRINT_MEDIUM, ' was telefragged by ')
            engine.bprint(defs.PRINT_MEDIUM, attacker.owner.netname)
            engine.bprint(defs.PRINT_MEDIUM, "'s Satan's power\012")
            targ.frags -= 1
            targ.logfrag(targ)
            return 
            
        if targ.deathtype == 'squish':
            if defs.teamplay and targteam == attackerteam and attackerteam != None and targ != attacker:
                attacker.logfrag(attacker)
                attacker.frags -= 1
                engine.bprint(defs.PRINT_MEDIUM, attacker.netname)
                engine.bprint(defs.PRINT_MEDIUM, ' squished a teammate\012')
                return 
                
            elif attacker.classname == 'player' and attacker != targ:
                engine.bprint(defs.PRINT_MEDIUM, attacker.netname)
                engine.bprint(defs.PRINT_MEDIUM, ' squishes ')
                engine.bprint(defs.PRINT_MEDIUM, targ.netname)
                engine.bprint(defs.PRINT_MEDIUM, '\012')
                attacker.logfrag(targ)
                attacker.frags += 1
                return 
                
            else:
                targ.logfrag(targ)
                targ.frags -= 1 #  killed self
                engine.bprint(defs.PRINT_MEDIUM, targ.netname)
                engine.bprint(defs.PRINT_MEDIUM, ' was squished\012')
                return 
                
            
        if attacker.classname == 'player':
            if targ == attacker:
                #  killed self
                attacker.logfrag(attacker)
                attacker.frags -= 1
                engine.bprint(defs.PRINT_MEDIUM, targ.netname)
                if targ.deathtype == 'grenade':
                    engine.bprint(defs.PRINT_MEDIUM, ' tries to put the pin back in\012')
                elif targ.deathtype == 'rocket':
                    engine.bprint(defs.PRINT_MEDIUM, ' becomes bored with life\012')
                elif targ.weapon == 64 and targ.waterlevel > 1:
                    if targ.watertype == defs.CONTENT_SLIME:
                        engine.bprint(defs.PRINT_MEDIUM, ' discharges into the slime\012')
                    elif targ.watertype == defs.CONTENT_LAVA:
                        engine.bprint(defs.PRINT_MEDIUM, ' discharges into the lava\012')
                    else:
                        engine.bprint(defs.PRINT_MEDIUM, ' discharges into the water.\012')
                    
                else:
                    engine.bprint(defs.PRINT_MEDIUM, ' becomes bored with life\012')
                return 
                
            elif (defs.teamplay == 2) and (targteam == attackerteam) and (attackerteam != None):
                if rnum < 0.25:
                    deathstring = ' mows down a teammate\012'
                elif rnum < 0.50:
                    deathstring = ' checks his glasses\012'
                elif rnum < 0.75:
                    deathstring = ' gets a frag for the other team\012'
                else:
                    deathstring = ' loses another friend\012'
                engine.bprint(defs.PRINT_MEDIUM, attacker.netname)
                engine.bprint(defs.PRINT_MEDIUM, deathstring)
                attacker.frags -= 1
                # ZOID 12-13-96:  killing a teammate logs as suicide
                attacker.logfrag(attacker)
                return 
                
            else:
                attacker.logfrag(targ)
                attacker.frags += 1
                rnum = attacker.weapon
                if targ.deathtype == 'nail':
                    deathstring = ' was nailed by '
                    deathstring2 = '\012'
                    
                elif targ.deathtype == 'supernail':
                    deathstring = ' was punctured by '
                    deathstring2 = '\012'
                    
                elif targ.deathtype == 'grenade':
                    deathstring = ' eats '
                    deathstring2 = "'s pineapple\012"
                    if targ.health < -40:
                        deathstring = ' was gibbed by '
                        deathstring2 = "'s grenade\012"
                        
                    
                elif targ.deathtype == 'rocket':
                    if attacker.super_damage_finished > 0 and targ.health < -40:
                        rnum = random.random()
                        if rnum < 0.3:
                            deathstring = ' was brutalized by '
                        elif rnum < 0.6:
                            deathstring = ' was smeared by '
                        else:
                            engine.bprint(defs.PRINT_MEDIUM, attacker.netname)
                            engine.bprint(defs.PRINT_MEDIUM, ' rips ')
                            engine.bprint(defs.PRINT_MEDIUM, targ.netname)
                            engine.bprint(defs.PRINT_MEDIUM, ' a new one\012')
                            return 
                            
                        deathstring2 = "'s quad rocket\012"
                        
                    else:
                        deathstring = ' rides '
                        deathstring2 = "'s rocket\012"
                        if targ.health < -40:
                            deathstring = ' was gibbed by '
                            deathstring2 = "'s rocket\012"
                            
                        
                    
                elif rnum == defs.IT_AXE:
                    deathstring = ' was ax-murdered by '
                    deathstring2 = '\012'
                    
                elif rnum == defs.IT_SHOTGUN:
                    deathstring = ' chewed on '
                    deathstring2 = "'s boomstick\012"
                    
                elif rnum == defs.IT_SUPER_SHOTGUN:
                    deathstring = ' ate 2 loads of '
                    deathstring2 = "'s buckshot\012"
                    
                elif rnum == defs.IT_LIGHTNING:
                    deathstring = ' accepts '
                    if attacker.waterlevel > 1:
                        deathstring2 = "'s discharge\012"
                    else:
                        deathstring2 = "'s shaft\012"
                    
                engine.bprint(defs.PRINT_MEDIUM, targ.netname)
                engine.bprint(defs.PRINT_MEDIUM, deathstring)
                engine.bprint(defs.PRINT_MEDIUM, attacker.netname)
                engine.bprint(defs.PRINT_MEDIUM, deathstring2)
                
            return 
            
        else:
            targ.logfrag(targ)
            targ.frags -= 1 #  killed self
            rnum = targ.watertype
            engine.bprint(defs.PRINT_MEDIUM, targ.netname)
            if rnum == -3:
                if random.random() < 0.5:
                    engine.bprint(defs.PRINT_MEDIUM, ' sleeps with the fishes\012')
                else:
                    engine.bprint(defs.PRINT_MEDIUM, ' sucks it down\012')
                return 
                
            elif rnum == -4:
                if random.random() < 0.5:
                    engine.bprint(defs.PRINT_MEDIUM, ' gulped a load of slime\012')
                else:
                    engine.bprint(defs.PRINT_MEDIUM, " can't exist on slime alone\012")
                return 
                
            elif rnum == -5:
                if targ.health < -15:
                    engine.bprint(defs.PRINT_MEDIUM, ' burst into flames\012')
                    return 
                    
                if random.random() < 0.5:
                    engine.bprint(defs.PRINT_MEDIUM, ' turned into hot slag\012')
                else:
                    engine.bprint(defs.PRINT_MEDIUM, ' visits the Volcano God\012')
                return 
                
            if attacker.classname == 'explo_box':
                engine.bprint(defs.PRINT_MEDIUM, ' blew up\012')
                return 
                
            if targ.deathtype == 'falling':
                engine.bprint(defs.PRINT_MEDIUM, ' fell to his death\012')
                return 
                
            if targ.deathtype == 'nail' or targ.deathtype == 'supernail':
                engine.bprint(defs.PRINT_MEDIUM, ' was spiked\012')
                return 
                
            if targ.deathtype == 'laser':
                engine.bprint(defs.PRINT_MEDIUM, ' was zapped\012')
                return 
                
            if attacker.classname == 'fireball':
                engine.bprint(defs.PRINT_MEDIUM, ' ate a lavaball\012')
                return 
                
            if attacker.classname == 'trigger_changelevel':
                engine.bprint(defs.PRINT_MEDIUM, ' tried to leave\012')
                return 
                
            engine.bprint(defs.PRINT_MEDIUM, ' died\012')
            
        
    


def qwp_reset_client(*qwp_extra):
    global modelindex_eyes
    global modelindex_player
    global nextmap
    global intermission_running
    global intermission_exittime
    modelindex_eyes = 0
    modelindex_player = 0
    nextmap = None
    intermission_running = 0
    intermission_exittime = 0
