###
### Generated by QuakeC -> Python translator
### Id: qc2python.py,v 1.5 2001/02/05 21:15:44 barryp Exp 
###
from qwpython.qwsv import engine, Vector
from qwpython.qcsupport import qc

import defs
import subs
import random
import math
import weapons

#  ALL LIGHTS SHOULD BE 0 1 0 IN COLOR ALL OTHER ITEMS SHOULD
# BE .8 .3 .4 IN COLOR 

def SUB_regen(*qwp_extra):
    qc.self.model = qc.self.mdl #  restore original model
    qc.self.solid = defs.SOLID_TRIGGER #  allow it to be touched again
    qc.self.sound(defs.CHAN_VOICE, 'items/itembk2.wav', 1, defs.ATTN_NORM) #  play respawn sound
    qc.setorigin(qc.self, qc.self.origin)
    
# QUAKED noclass (0 0 0) (-8 -8 -8) (8 8 8)
# prints a warning message when spawned
# 

def noclass(*qwp_extra):
    engine.dprint('noclass spawned at')
    engine.dprint(str(qc.self.origin))
    engine.dprint('\012')
    qc.self.remove()
    

def q_touch(*qwp_extra):
    stemp = engine.world
    best = 0
    s = None
    if qc.other.classname != 'player':
        return 
    if qc.other.health <= 0:
        return 
    qc.self.mdl = qc.self.model
    qc.other.sound(defs.CHAN_VOICE, qc.self.noise, 1, defs.ATTN_NORM)
    qc.other.stuffcmd('bf\012')
    qc.self.solid = defs.SOLID_NOT
    qc.other.items |= defs.IT_QUAD
    qc.self.model = defs.string_null
    if defs.deathmatch == 4:
        qc.other.armortype = 0
        qc.other.armorvalue = 0 * 0.01
        qc.other.ammo_cells = 0
        
    #  do the apropriate action
    qc.other.super_time = 1
    qc.other.super_damage_finished = qc.self.cnt
    s = str(round(qc.other.super_damage_finished - qc.time))
    engine.bprint(defs.PRINT_LOW, qc.other.netname)
    if defs.deathmatch == 4:
        engine.bprint(defs.PRINT_LOW, ' recovered an OctaPower with ')
    else:
        engine.bprint(defs.PRINT_LOW, ' recovered a Quad with ')
    engine.bprint(defs.PRINT_LOW, s)
    engine.bprint(defs.PRINT_LOW, ' seconds remaining!\012')
    defs.activator = qc.other
    subs.SUB_UseTargets() #  fire all targets / killtargets
    

def DropQuad(timeleft, *qwp_extra):
    item = engine.world
    item = qc.spawn()
    item.origin = qc.self.origin
    item.velocity %= Vector(None, None, 300)
    item.velocity %= Vector(-100 + (random.random() * 200), None, None)
    item.velocity %= Vector(None, -100 + (random.random() * 200), None)
    item.flags = defs.FL_ITEM
    item.solid = defs.SOLID_TRIGGER
    item.movetype = defs.MOVETYPE_TOSS
    item.noise = 'items/damage.wav'
    item.setmodel('progs/quaddama.mdl')
    qc.setsize(item, Vector(-16, -16, -24), Vector(16, 16, 32))
    item.cnt = qc.time + timeleft
    item.touch = q_touch
    item.nextthink = qc.time + timeleft #  remove it with the time left on it
    item.think = subs.SUB_Remove
    

def r_touch(*qwp_extra):
    stemp = engine.world
    best = 0
    s = None
    if qc.other.classname != 'player':
        return 
    if qc.other.health <= 0:
        return 
    qc.self.mdl = qc.self.model
    qc.other.sound(defs.CHAN_VOICE, qc.self.noise, 1, defs.ATTN_NORM)
    qc.other.stuffcmd('bf\012')
    qc.self.solid = defs.SOLID_NOT
    qc.other.items |= defs.IT_INVISIBILITY
    qc.self.model = defs.string_null
    #  do the apropriate action
    qc.other.invisible_time = 1
    qc.other.invisible_finished = qc.self.cnt
    s = str(round(qc.other.invisible_finished - qc.time))
    engine.bprint(defs.PRINT_LOW, qc.other.netname)
    engine.bprint(defs.PRINT_LOW, ' recovered a Ring with ')
    engine.bprint(defs.PRINT_LOW, s)
    engine.bprint(defs.PRINT_LOW, ' seconds remaining!\012')
    defs.activator = qc.other
    subs.SUB_UseTargets() #  fire all targets / killtargets
    

def DropRing(timeleft, *qwp_extra):
    item = engine.world
    item = qc.spawn()
    item.origin = qc.self.origin
    item.velocity %= Vector(None, None, 300)
    item.velocity %= Vector(-100 + (random.random() * 200), None, None)
    item.velocity %= Vector(None, -100 + (random.random() * 200), None)
    item.flags = defs.FL_ITEM
    item.solid = defs.SOLID_TRIGGER
    item.movetype = defs.MOVETYPE_TOSS
    item.noise = 'items/inv1.wav'
    item.setmodel('progs/invisibl.mdl')
    qc.setsize(item, Vector(-16, -16, -24), Vector(16, 16, 32))
    item.cnt = qc.time + timeleft
    item.touch = r_touch
    item.nextthink = qc.time + timeleft #  remove after 30 seconds
    item.think = subs.SUB_Remove
    
# 
# ============
# PlaceItem
# 
# plants the object on the floor
# ============
# 

def PlaceItem(*qwp_extra):
    oldz = 0
    qc.self.mdl = qc.self.model #  so it can be restored on respawn
    qc.self.flags = defs.FL_ITEM #  make extra wide
    qc.self.solid = defs.SOLID_TRIGGER
    qc.self.movetype = defs.MOVETYPE_TOSS
    qc.self.velocity = Vector(0, 0, 0)
    qc.self.origin %= Vector(None, None, qc.self.origin.z + 6)
    oldz = qc.self.origin.z
    if not qc.droptofloor():
        engine.dprint('Bonus item fell out of level at ')
        engine.dprint(str(qc.self.origin))
        engine.dprint('\012')
        qc.self.remove()
        return 
        
    
# 
# ============
# StartItem
# 
# Sets the clipping size and plants the object on the floor
# ============
# 

def StartItem(*qwp_extra):
    qc.self.nextthink = qc.time + 0.2 #  items start after other solids
    qc.self.think = PlaceItem
    
# 
# =========================================================================
# 
# HEALTH BOX
# 
# =========================================================================
# 
# 
#  T_Heal: add health to an entity, limiting health to max_health
#  "ignore" will ignore max_health limit
# 

def T_Heal(e, healamount, ignore, *qwp_extra):
    if e.health <= 0:
        return 0
    if (not ignore) and (e.health >= qc.other.max_health):
        return 0
    healamount = math.ceil(healamount)
    e.health += healamount
    if (not ignore) and (e.health >= qc.other.max_health):
        e.health = qc.other.max_health
    if e.health > 250:
        e.health = 250
    return 1
    
# QUAKED item_health (.3 .3 1) (0 0 0) (32 32 32) rotten megahealth
# Health box. Normally gives 25 points.
# Rotten box heals 5-10 points,
# megahealth will add 100 health, then 
# rot you down to your maximum health limit, 
# one point per second.
# 
H_ROTTEN = 1
H_MEGA = 2

def item_health(*qwp_extra):
    qc.self.touch = health_touch
    if qc.self.spawnflags & H_ROTTEN:
        engine.precache_model('maps/b_bh10.bsp')
        engine.precache_sound('items/r_item1.wav')
        qc.self.setmodel('maps/b_bh10.bsp')
        qc.self.noise = 'items/r_item1.wav'
        qc.self.healamount = 15
        qc.self.healtype = 0
        
    elif qc.self.spawnflags & H_MEGA:
        engine.precache_model('maps/b_bh100.bsp')
        engine.precache_sound('items/r_item2.wav')
        qc.self.setmodel('maps/b_bh100.bsp')
        qc.self.noise = 'items/r_item2.wav'
        qc.self.healamount = 100
        qc.self.healtype = 2
        
    else:
        engine.precache_model('maps/b_bh25.bsp')
        engine.precache_sound('items/health1.wav')
        qc.self.setmodel('maps/b_bh25.bsp')
        qc.self.noise = 'items/health1.wav'
        qc.self.healamount = 25
        qc.self.healtype = 1
        
    qc.setsize(qc.self, Vector(0, 0, 0), Vector(32, 32, 56))
    StartItem()
    

def health_touch(*qwp_extra):
    amount = 0
    s = None
    if defs.deathmatch == 4:
        if qc.other.invincible_time > 0:
            return 
    if qc.other.classname != 'player':
        return 
    if qc.self.healtype == 2: #  Megahealth?  Ignore max_health...
        if qc.other.health >= 250:
            return 
        if not T_Heal(qc.other, qc.self.healamount, 1):
            return 
        
    else:
        if not T_Heal(qc.other, qc.self.healamount, 0):
            return 
        
    qc.other.sprint(defs.PRINT_LOW, 'You receive ')
    s = str(qc.self.healamount)
    qc.other.sprint(defs.PRINT_LOW, s)
    qc.other.sprint(defs.PRINT_LOW, ' health\012')
    #  health touch sound
    qc.other.sound(defs.CHAN_ITEM, qc.self.noise, 1, defs.ATTN_NORM)
    qc.other.stuffcmd('bf\012')
    qc.self.model = defs.string_null
    qc.self.solid = defs.SOLID_NOT
    #  Megahealth = rot down the player's super health
    if qc.self.healtype == 2:
        qc.other.items |= defs.IT_SUPERHEALTH
        if defs.deathmatch != 4:
            qc.self.nextthink = qc.time + 5
            qc.self.think = item_megahealth_rot
            
        qc.self.owner = qc.other
        
    else:
        if defs.deathmatch != 2: #  deathmatch 2 is the silly old rules
            qc.self.nextthink = qc.time + 20
            qc.self.think = SUB_regen
            
        
    defs.activator = qc.other
    subs.SUB_UseTargets() #  fire all targets / killtargets
    

def item_megahealth_rot(*qwp_extra):
    qc.other = qc.self.owner
    if qc.other.health > qc.other.max_health:
        qc.other.health -= 1
        qc.self.nextthink = qc.time + 1
        return 
        
    #  it is possible for a player to die and respawn between rots, so don't
    #  just blindly subtract the flag off
    qc.other.items -= qc.other.items & defs.IT_SUPERHEALTH
    if defs.deathmatch != 2: #  deathmatch 2 is silly old rules
        qc.self.nextthink = qc.time + 20
        qc.self.think = SUB_regen
        
    
# 
# ===============================================================================
# 
# ARMOR
# 
# ===============================================================================
# 

def armor_touch(*qwp_extra):
    type = 0
    value = 0
    bit = 0
    if qc.other.health <= 0:
        return 
    if qc.other.classname != 'player':
        return 
    if defs.deathmatch == 4:
        if qc.other.invincible_time > 0:
            return 
    if qc.self.classname == 'item_armor1':
        type = 0.3
        value = 100
        bit = defs.IT_ARMOR1
        
    if qc.self.classname == 'item_armor2':
        type = 0.6
        value = 150
        bit = defs.IT_ARMOR2
        
    if qc.self.classname == 'item_armorInv':
        type = 0.8
        value = 200
        bit = defs.IT_ARMOR3
        
    if qc.other.armortype * qc.other.armorvalue >= type * value:
        return 
    qc.other.armortype = type
    qc.other.armorvalue = value
    qc.other.items = qc.other.items - (qc.other.items & (defs.IT_ARMOR1 | defs.IT_ARMOR2 | defs.IT_ARMOR3)) + bit
    qc.self.solid = defs.SOLID_NOT
    qc.self.model = defs.string_null
    if defs.deathmatch != 2:
        qc.self.nextthink = qc.time + 20
    qc.self.think = SUB_regen
    qc.other.sprint(defs.PRINT_LOW, 'You got armor\012')
    #  armor touch sound
    qc.other.sound(defs.CHAN_ITEM, 'items/armor1.wav', 1, defs.ATTN_NORM)
    qc.other.stuffcmd('bf\012')
    defs.activator = qc.other
    subs.SUB_UseTargets() #  fire all targets / killtargets
    
# QUAKED item_armor1 (0 .5 .8) (-16 -16 0) (16 16 32)
# 

def item_armor1(*qwp_extra):
    qc.self.touch = armor_touch
    engine.precache_model('progs/armor.mdl')
    qc.self.setmodel('progs/armor.mdl')
    qc.self.skin = 0
    qc.setsize(qc.self, Vector(-16, -16, 0), Vector(16, 16, 56))
    StartItem()
    
# QUAKED item_armor2 (0 .5 .8) (-16 -16 0) (16 16 32)
# 

def item_armor2(*qwp_extra):
    qc.self.touch = armor_touch
    engine.precache_model('progs/armor.mdl')
    qc.self.setmodel('progs/armor.mdl')
    qc.self.skin = 1
    qc.setsize(qc.self, Vector(-16, -16, 0), Vector(16, 16, 56))
    StartItem()
    
# QUAKED item_armorInv (0 .5 .8) (-16 -16 0) (16 16 32)
# 

def item_armorInv(*qwp_extra):
    qc.self.touch = armor_touch
    engine.precache_model('progs/armor.mdl')
    qc.self.setmodel('progs/armor.mdl')
    qc.self.skin = 2
    qc.setsize(qc.self, Vector(-16, -16, 0), Vector(16, 16, 56))
    StartItem()
    
# 
# ===============================================================================
# 
# WEAPONS
# 
# ===============================================================================
# 

def bound_other_ammo(*qwp_extra):
    if qc.other.ammo_shells > 100:
        qc.other.ammo_shells = 100
    if qc.other.ammo_nails > 200:
        qc.other.ammo_nails = 200
    if qc.other.ammo_rockets > 100:
        qc.other.ammo_rockets = 100
    if qc.other.ammo_cells > 100:
        qc.other.ammo_cells = 100
    

def RankForWeapon(w, *qwp_extra):
    if w == defs.IT_LIGHTNING:
        return 1
    if w == defs.IT_ROCKET_LAUNCHER:
        return 2
    if w == defs.IT_SUPER_NAILGUN:
        return 3
    if w == defs.IT_GRENADE_LAUNCHER:
        return 4
    if w == defs.IT_SUPER_SHOTGUN:
        return 5
    if w == defs.IT_NAILGUN:
        return 6
    return 7
    

def WeaponCode(w, *qwp_extra):
    if w == defs.IT_SUPER_SHOTGUN:
        return 3
    if w == defs.IT_NAILGUN:
        return 4
    if w == defs.IT_SUPER_NAILGUN:
        return 5
    if w == defs.IT_GRENADE_LAUNCHER:
        return 6
    if w == defs.IT_ROCKET_LAUNCHER:
        return 7
    if w == defs.IT_LIGHTNING:
        return 8
    return 1
    
# 
# =============
# Deathmatch_Weapon
# 
# Deathmatch weapon change rules for picking up a weapon
# 
# .float          ammo_shells, ammo_nails, ammo_rockets, ammo_cells;
# =============
# 

def Deathmatch_Weapon(old, new, *qwp_extra):
    or0 = 0
    nr = 0
    #  change self.weapon if desired
    or0 = RankForWeapon(qc.self.weapon)
    nr = RankForWeapon(new)
    if nr < or0:
        qc.self.weapon = new
    
# 
# =============
# weapon_touch
# =============
# 

def weapon_touch(*qwp_extra):
    hadammo = 0
    best = 0
    new = 0
    old = 0
    stemp = engine.world
    leave = 0
    #  For client weapon_switch
    w_switch = 0
    if not (qc.other.flags & defs.FL_CLIENT):
        return 
    if (qc.stof(qc.other.infokey('w_switch'))) == 0:
        w_switch = 8
    else:
        w_switch = qc.stof(qc.other.infokey('w_switch'))
    #  if the player was using his best weapon, change up to the new one if better          
    stemp = qc.self
    qc.self = qc.other
    best = weapons.W_BestWeapon()
    qc.self = stemp
    if defs.deathmatch == 2 or defs.deathmatch == 3 or defs.deathmatch == 5:
        leave = 1
    else:
        leave = 0
    if qc.self.classname == 'weapon_nailgun':
        if leave and (qc.other.items & defs.IT_NAILGUN):
            return 
        hadammo = qc.other.ammo_nails
        new = defs.IT_NAILGUN
        qc.other.ammo_nails += 30
        
    elif qc.self.classname == 'weapon_supernailgun':
        if leave and (qc.other.items & defs.IT_SUPER_NAILGUN):
            return 
        hadammo = qc.other.ammo_rockets
        new = defs.IT_SUPER_NAILGUN
        qc.other.ammo_nails += 30
        
    elif qc.self.classname == 'weapon_supershotgun':
        if leave and (qc.other.items & defs.IT_SUPER_SHOTGUN):
            return 
        hadammo = qc.other.ammo_rockets
        new = defs.IT_SUPER_SHOTGUN
        qc.other.ammo_shells += 5
        
    elif qc.self.classname == 'weapon_rocketlauncher':
        if leave and (qc.other.items & defs.IT_ROCKET_LAUNCHER):
            return 
        hadammo = qc.other.ammo_rockets
        new = defs.IT_ROCKET_LAUNCHER
        qc.other.ammo_rockets += 5
        
    elif qc.self.classname == 'weapon_grenadelauncher':
        if leave and (qc.other.items & defs.IT_GRENADE_LAUNCHER):
            return 
        hadammo = qc.other.ammo_rockets
        new = defs.IT_GRENADE_LAUNCHER
        qc.other.ammo_rockets += 5
        
    elif qc.self.classname == 'weapon_lightning':
        if leave and (qc.other.items & defs.IT_LIGHTNING):
            return 
        hadammo = qc.other.ammo_rockets
        new = defs.IT_LIGHTNING
        qc.other.ammo_cells += 15
        
    else:
        qc.objerror('weapon_touch: unknown classname')
    qc.other.sprint(defs.PRINT_LOW, 'You got the ')
    qc.other.sprint(defs.PRINT_LOW, qc.self.netname)
    qc.other.sprint(defs.PRINT_LOW, '\012')
    #  weapon touch sound
    qc.other.sound(defs.CHAN_ITEM, 'weapons/pkup.wav', 1, defs.ATTN_NORM)
    qc.other.stuffcmd('bf\012')
    bound_other_ammo()
    #  change to the weapon
    old = qc.other.items
    qc.other.items |= new
    stemp = qc.self
    qc.self = qc.other
    if WeaponCode(new) <= w_switch:
        if qc.self.flags & defs.FL_INWATER:
            if new != defs.IT_LIGHTNING:
                Deathmatch_Weapon(old, new)
                
            
        else:
            Deathmatch_Weapon(old, new)
            
        
    weapons.W_SetCurrentAmmo()
    qc.self = stemp
    if leave:
        return 
    if defs.deathmatch != 3 or defs.deathmatch != 5:
        #  remove it in single player, or setup for respawning in deathmatch
        qc.self.model = defs.string_null
        qc.self.solid = defs.SOLID_NOT
        if defs.deathmatch != 2:
            qc.self.nextthink = qc.time + 30
        qc.self.think = SUB_regen
        
    defs.activator = qc.other
    subs.SUB_UseTargets() #  fire all targets / killtargets
    
# QUAKED weapon_supershotgun (0 .5 .8) (-16 -16 0) (16 16 32)
# 

def weapon_supershotgun(*qwp_extra):
    if defs.deathmatch <= 3:
        engine.precache_model('progs/g_shot.mdl')
        qc.self.setmodel('progs/g_shot.mdl')
        qc.self.weapon = defs.IT_SUPER_SHOTGUN
        qc.self.netname = 'Double-barrelled Shotgun'
        qc.self.touch = weapon_touch
        qc.setsize(qc.self, Vector(-16, -16, 0), Vector(16, 16, 56))
        StartItem()
        
    
# QUAKED weapon_nailgun (0 .5 .8) (-16 -16 0) (16 16 32)
# 

def weapon_nailgun(*qwp_extra):
    if defs.deathmatch <= 3:
        engine.precache_model('progs/g_nail.mdl')
        qc.self.setmodel('progs/g_nail.mdl')
        qc.self.weapon = defs.IT_NAILGUN
        qc.self.netname = 'nailgun'
        qc.self.touch = weapon_touch
        qc.setsize(qc.self, Vector(-16, -16, 0), Vector(16, 16, 56))
        StartItem()
        
    
# QUAKED weapon_supernailgun (0 .5 .8) (-16 -16 0) (16 16 32)
# 

def weapon_supernailgun(*qwp_extra):
    if defs.deathmatch <= 3:
        engine.precache_model('progs/g_nail2.mdl')
        qc.self.setmodel('progs/g_nail2.mdl')
        qc.self.weapon = defs.IT_SUPER_NAILGUN
        qc.self.netname = 'Super Nailgun'
        qc.self.touch = weapon_touch
        qc.setsize(qc.self, Vector(-16, -16, 0), Vector(16, 16, 56))
        StartItem()
        
    
# QUAKED weapon_grenadelauncher (0 .5 .8) (-16 -16 0) (16 16 32)
# 

def weapon_grenadelauncher(*qwp_extra):
    if defs.deathmatch <= 3:
        engine.precache_model('progs/g_rock.mdl')
        qc.self.setmodel('progs/g_rock.mdl')
        qc.self.weapon = 3
        qc.self.netname = 'Grenade Launcher'
        qc.self.touch = weapon_touch
        qc.setsize(qc.self, Vector(-16, -16, 0), Vector(16, 16, 56))
        StartItem()
        
    
# QUAKED weapon_rocketlauncher (0 .5 .8) (-16 -16 0) (16 16 32)
# 

def weapon_rocketlauncher(*qwp_extra):
    if defs.deathmatch <= 3:
        engine.precache_model('progs/g_rock2.mdl')
        qc.self.setmodel('progs/g_rock2.mdl')
        qc.self.weapon = 3
        qc.self.netname = 'Rocket Launcher'
        qc.self.touch = weapon_touch
        qc.setsize(qc.self, Vector(-16, -16, 0), Vector(16, 16, 56))
        StartItem()
        
    
# QUAKED weapon_lightning (0 .5 .8) (-16 -16 0) (16 16 32)
# 

def weapon_lightning(*qwp_extra):
    if defs.deathmatch <= 3:
        engine.precache_model('progs/g_light.mdl')
        qc.self.setmodel('progs/g_light.mdl')
        qc.self.weapon = 3
        qc.self.netname = 'Thunderbolt'
        qc.self.touch = weapon_touch
        qc.setsize(qc.self, Vector(-16, -16, 0), Vector(16, 16, 56))
        StartItem()
        
    
# 
# ===============================================================================
# 
# AMMO
# 
# ===============================================================================
# 

def ammo_touch(*qwp_extra):
    stemp = engine.world
    best = 0
    if qc.other.classname != 'player':
        return 
    if qc.other.health <= 0:
        return 
    #  if the player was using his best weapon, change up to the new one if better          
    stemp = qc.self
    qc.self = qc.other
    best = weapons.W_BestWeapon()
    qc.self = stemp
    #  shotgun
    if qc.self.weapon == 1:
        if qc.other.ammo_shells >= 100:
            return 
        qc.other.ammo_shells += qc.self.aflag
        
    #  spikes
    if qc.self.weapon == 2:
        if qc.other.ammo_nails >= 200:
            return 
        qc.other.ammo_nails += qc.self.aflag
        
    #       rockets
    if qc.self.weapon == 3:
        if qc.other.ammo_rockets >= 100:
            return 
        qc.other.ammo_rockets += qc.self.aflag
        
    #       cells
    if qc.self.weapon == 4:
        if qc.other.ammo_cells >= 100:
            return 
        qc.other.ammo_cells += qc.self.aflag
        
    bound_other_ammo()
    qc.other.sprint(defs.PRINT_LOW, 'You got the ')
    qc.other.sprint(defs.PRINT_LOW, qc.self.netname)
    qc.other.sprint(defs.PRINT_LOW, '\012')
    #  ammo touch sound
    qc.other.sound(defs.CHAN_ITEM, 'weapons/lock4.wav', 1, defs.ATTN_NORM)
    qc.other.stuffcmd('bf\012')
    #  change to a better weapon if appropriate
    if qc.other.weapon == best:
        stemp = qc.self
        qc.self = qc.other
        qc.self.weapon = weapons.W_BestWeapon()
        weapons.W_SetCurrentAmmo()
        qc.self = stemp
        
    #  if changed current ammo, update it
    stemp = qc.self
    qc.self = qc.other
    weapons.W_SetCurrentAmmo()
    qc.self = stemp
    #  remove it in single player, or setup for respawning in deathmatch
    qc.self.model = defs.string_null
    qc.self.solid = defs.SOLID_NOT
    if defs.deathmatch != 2:
        qc.self.nextthink = qc.time + 30
    #  Xian -- If playing in DM 3.0 mode, halve the time ammo respawns        
    if defs.deathmatch == 3 or defs.deathmatch == 5:
        qc.self.nextthink = qc.time + 15
    qc.self.think = SUB_regen
    defs.activator = qc.other
    subs.SUB_UseTargets() #  fire all targets / killtargets
    
WEAPON_BIG2 = 1
# QUAKED item_shells (0 .5 .8) (0 0 0) (32 32 32) big
# 

def item_shells(*qwp_extra):
    if defs.deathmatch == 4:
        return 
    qc.self.touch = ammo_touch
    if qc.self.spawnflags & WEAPON_BIG2:
        engine.precache_model('maps/b_shell1.bsp')
        qc.self.setmodel('maps/b_shell1.bsp')
        qc.self.aflag = 40
        
    else:
        engine.precache_model('maps/b_shell0.bsp')
        qc.self.setmodel('maps/b_shell0.bsp')
        qc.self.aflag = 20
        
    qc.self.weapon = 1
    qc.self.netname = 'shells'
    qc.setsize(qc.self, Vector(0, 0, 0), Vector(32, 32, 56))
    StartItem()
    
# QUAKED item_spikes (0 .5 .8) (0 0 0) (32 32 32) big
# 

def item_spikes(*qwp_extra):
    if defs.deathmatch == 4:
        return 
    qc.self.touch = ammo_touch
    if qc.self.spawnflags & WEAPON_BIG2:
        engine.precache_model('maps/b_nail1.bsp')
        qc.self.setmodel('maps/b_nail1.bsp')
        qc.self.aflag = 50
        
    else:
        engine.precache_model('maps/b_nail0.bsp')
        qc.self.setmodel('maps/b_nail0.bsp')
        qc.self.aflag = 25
        
    qc.self.weapon = 2
    qc.self.netname = 'nails'
    qc.setsize(qc.self, Vector(0, 0, 0), Vector(32, 32, 56))
    StartItem()
    
# QUAKED item_rockets (0 .5 .8) (0 0 0) (32 32 32) big
# 

def item_rockets(*qwp_extra):
    if defs.deathmatch == 4:
        return 
    qc.self.touch = ammo_touch
    if qc.self.spawnflags & WEAPON_BIG2:
        engine.precache_model('maps/b_rock1.bsp')
        qc.self.setmodel('maps/b_rock1.bsp')
        qc.self.aflag = 10
        
    else:
        engine.precache_model('maps/b_rock0.bsp')
        qc.self.setmodel('maps/b_rock0.bsp')
        qc.self.aflag = 5
        
    qc.self.weapon = 3
    qc.self.netname = 'rockets'
    qc.setsize(qc.self, Vector(0, 0, 0), Vector(32, 32, 56))
    StartItem()
    
# QUAKED item_cells (0 .5 .8) (0 0 0) (32 32 32) big
# 

def item_cells(*qwp_extra):
    if defs.deathmatch == 4:
        return 
    qc.self.touch = ammo_touch
    if qc.self.spawnflags & WEAPON_BIG2:
        engine.precache_model('maps/b_batt1.bsp')
        qc.self.setmodel('maps/b_batt1.bsp')
        qc.self.aflag = 12
        
    else:
        engine.precache_model('maps/b_batt0.bsp')
        qc.self.setmodel('maps/b_batt0.bsp')
        qc.self.aflag = 6
        
    qc.self.weapon = 4
    qc.self.netname = 'cells'
    qc.setsize(qc.self, Vector(0, 0, 0), Vector(32, 32, 56))
    StartItem()
    
# QUAKED item_weapon (0 .5 .8) (0 0 0) (32 32 32) shotgun rocket spikes big
# DO NOT USE THIS!!!! IT WILL BE REMOVED!
# 
WEAPON_SHOTGUN = 1
WEAPON_ROCKET = 2
WEAPON_SPIKES = 4
WEAPON_BIG = 8

def item_weapon(*qwp_extra):
    qc.self.touch = ammo_touch
    if qc.self.spawnflags & WEAPON_SHOTGUN:
        if qc.self.spawnflags & WEAPON_BIG:
            engine.precache_model('maps/b_shell1.bsp')
            qc.self.setmodel('maps/b_shell1.bsp')
            qc.self.aflag = 40
            
        else:
            engine.precache_model('maps/b_shell0.bsp')
            qc.self.setmodel('maps/b_shell0.bsp')
            qc.self.aflag = 20
            
        qc.self.weapon = 1
        qc.self.netname = 'shells'
        
    if qc.self.spawnflags & WEAPON_SPIKES:
        if qc.self.spawnflags & WEAPON_BIG:
            engine.precache_model('maps/b_nail1.bsp')
            qc.self.setmodel('maps/b_nail1.bsp')
            qc.self.aflag = 40
            
        else:
            engine.precache_model('maps/b_nail0.bsp')
            qc.self.setmodel('maps/b_nail0.bsp')
            qc.self.aflag = 20
            
        qc.self.weapon = 2
        qc.self.netname = 'spikes'
        
    if qc.self.spawnflags & WEAPON_ROCKET:
        if qc.self.spawnflags & WEAPON_BIG:
            engine.precache_model('maps/b_rock1.bsp')
            qc.self.setmodel('maps/b_rock1.bsp')
            qc.self.aflag = 10
            
        else:
            engine.precache_model('maps/b_rock0.bsp')
            qc.self.setmodel('maps/b_rock0.bsp')
            qc.self.aflag = 5
            
        qc.self.weapon = 3
        qc.self.netname = 'rockets'
        
    qc.setsize(qc.self, Vector(0, 0, 0), Vector(32, 32, 56))
    StartItem()
    
# 
# ===============================================================================
# 
# KEYS
# 
# ===============================================================================
# 

def key_touch(*qwp_extra):
    stemp = engine.world
    best = 0
    if qc.other.classname != 'player':
        return 
    if qc.other.health <= 0:
        return 
    if qc.other.items & qc.self.items:
        return 
    qc.other.sprint(defs.PRINT_LOW, 'You got the ')
    qc.other.sprint(defs.PRINT_LOW, qc.self.netname)
    qc.other.sprint(defs.PRINT_LOW, '\012')
    qc.other.sound(defs.CHAN_ITEM, qc.self.noise, 1, defs.ATTN_NORM)
    qc.other.stuffcmd('bf\012')
    qc.other.items |= qc.self.items
    qc.self.solid = defs.SOLID_NOT
    qc.self.model = defs.string_null
    defs.activator = qc.other
    subs.SUB_UseTargets() #  fire all targets / killtargets
    

def key_setsounds(*qwp_extra):
    if qc.world.worldtype == 0:
        engine.precache_sound('misc/medkey.wav')
        qc.self.noise = 'misc/medkey.wav'
        
    if qc.world.worldtype == 1:
        engine.precache_sound('misc/runekey.wav')
        qc.self.noise = 'misc/runekey.wav'
        
    if qc.world.worldtype == 2:
        engine.precache_sound('misc/basekey.wav')
        qc.self.noise = 'misc/basekey.wav'
        
    
# QUAKED item_key1 (0 .5 .8) (-16 -16 -24) (16 16 32)
# SILVER key
# In order for keys to work
# you MUST set your maps
# worldtype to one of the
# following:
# 0: medieval
# 1: metal
# 2: base
# 

def item_key1(*qwp_extra):
    if qc.world.worldtype == 0:
        engine.precache_model('progs/w_s_key.mdl')
        qc.self.setmodel('progs/w_s_key.mdl')
        qc.self.netname = 'silver key'
        
    elif qc.world.worldtype == 1:
        engine.precache_model('progs/m_s_key.mdl')
        qc.self.setmodel('progs/m_s_key.mdl')
        qc.self.netname = 'silver runekey'
        
    elif qc.world.worldtype == 2:
        engine.precache_model('progs/b_s_key.mdl')
        qc.self.setmodel('progs/b_s_key.mdl')
        qc.self.netname = 'silver keycard'
        
    key_setsounds()
    qc.self.touch = key_touch
    qc.self.items = defs.IT_KEY1
    qc.setsize(qc.self, Vector(-16, -16, -24), Vector(16, 16, 32))
    StartItem()
    
# QUAKED item_key2 (0 .5 .8) (-16 -16 -24) (16 16 32)
# GOLD key
# In order for keys to work
# you MUST set your maps
# worldtype to one of the
# following:
# 0: medieval
# 1: metal
# 2: base
# 

def item_key2(*qwp_extra):
    if qc.world.worldtype == 0:
        engine.precache_model('progs/w_g_key.mdl')
        qc.self.setmodel('progs/w_g_key.mdl')
        qc.self.netname = 'gold key'
        
    if qc.world.worldtype == 1:
        engine.precache_model('progs/m_g_key.mdl')
        qc.self.setmodel('progs/m_g_key.mdl')
        qc.self.netname = 'gold runekey'
        
    if qc.world.worldtype == 2:
        engine.precache_model('progs/b_g_key.mdl')
        qc.self.setmodel('progs/b_g_key.mdl')
        qc.self.netname = 'gold keycard'
        
    key_setsounds()
    qc.self.touch = key_touch
    qc.self.items = defs.IT_KEY2
    qc.setsize(qc.self, Vector(-16, -16, -24), Vector(16, 16, 32))
    StartItem()
    
# 
# ===============================================================================
# 
# END OF LEVEL RUNES
# 
# ===============================================================================
# 

def sigil_touch(*qwp_extra):
    stemp = engine.world
    best = 0
    if qc.other.classname != 'player':
        return 
    if qc.other.health <= 0:
        return 
    qc.centerprint(qc.other, 'You got the rune!')
    qc.other.sound(defs.CHAN_ITEM, qc.self.noise, 1, defs.ATTN_NORM)
    qc.other.stuffcmd('bf\012')
    qc.self.solid = defs.SOLID_NOT
    qc.self.model = defs.string_null
    qc.serverflags |= qc.self.spawnflags & 15
    qc.self.classname = None #  so rune doors won't find it
    defs.activator = qc.other
    subs.SUB_UseTargets() #  fire all targets / killtargets
    
# QUAKED item_sigil (0 .5 .8) (-16 -16 -24) (16 16 32) E1 E2 E3 E4
# End of level sigil, pick up to end episode and return to jrstart.
# 

def item_sigil(*qwp_extra):
    if not qc.self.spawnflags:
        qc.objerror('no spawnflags')
    engine.precache_sound('misc/runekey.wav')
    qc.self.noise = 'misc/runekey.wav'
    if qc.self.spawnflags & 1:
        engine.precache_model('progs/end1.mdl')
        qc.self.setmodel('progs/end1.mdl')
        
    if qc.self.spawnflags & 2:
        engine.precache_model('progs/end2.mdl')
        qc.self.setmodel('progs/end2.mdl')
        
    if qc.self.spawnflags & 4:
        engine.precache_model('progs/end3.mdl')
        qc.self.setmodel('progs/end3.mdl')
        
    if qc.self.spawnflags & 8:
        engine.precache_model('progs/end4.mdl')
        qc.self.setmodel('progs/end4.mdl')
        
    qc.self.touch = sigil_touch
    qc.setsize(qc.self, Vector(-16, -16, -24), Vector(16, 16, 32))
    StartItem()
    
# 
# ===============================================================================
# 
# POWERUPS
# 
# ===============================================================================
# 

def powerup_touch(*qwp_extra):
    stemp = engine.world
    best = 0
    if qc.other.classname != 'player':
        return 
    if qc.other.health <= 0:
        return 
    qc.other.sprint(defs.PRINT_LOW, 'You got the ')
    qc.other.sprint(defs.PRINT_LOW, qc.self.netname)
    qc.other.sprint(defs.PRINT_LOW, '\012')
    qc.self.mdl = qc.self.model
    if (qc.self.classname == 'item_artifact_invulnerability') or (qc.self.classname == 'item_artifact_invisibility'):
        qc.self.nextthink = qc.time + 60 * 5
    else:
        qc.self.nextthink = qc.time + 60
    qc.self.think = SUB_regen
    qc.other.sound(defs.CHAN_VOICE, qc.self.noise, 1, defs.ATTN_NORM)
    qc.other.stuffcmd('bf\012')
    qc.self.solid = defs.SOLID_NOT
    qc.other.items |= qc.self.items
    qc.self.model = defs.string_null
    #  do the apropriate action
    if qc.self.classname == 'item_artifact_envirosuit':
        qc.other.rad_time = 1
        qc.other.radsuit_finished = qc.time + 30
        
    if qc.self.classname == 'item_artifact_invulnerability':
        qc.other.invincible_time = 1
        qc.other.invincible_finished = qc.time + 30
        
    if qc.self.classname == 'item_artifact_invisibility':
        qc.other.invisible_time = 1
        qc.other.invisible_finished = qc.time + 30
        
    if qc.self.classname == 'item_artifact_super_damage':
        if defs.deathmatch == 4:
            qc.other.armortype = 0
            qc.other.armorvalue = 0 * 0.01
            qc.other.ammo_cells = 0
            
        qc.other.super_time = 1
        qc.other.super_damage_finished = qc.time + 30
        
    defs.activator = qc.other
    subs.SUB_UseTargets() #  fire all targets / killtargets
    
# QUAKED item_artifact_invulnerability (0 .5 .8) (-16 -16 -24) (16 16 32)
# Player is invulnerable for 30 seconds
# 

def item_artifact_invulnerability(*qwp_extra):
    qc.self.touch = powerup_touch
    engine.precache_model('progs/invulner.mdl')
    engine.precache_sound('items/protect.wav')
    engine.precache_sound('items/protect2.wav')
    engine.precache_sound('items/protect3.wav')
    qc.self.noise = 'items/protect.wav'
    qc.self.setmodel('progs/invulner.mdl')
    qc.self.netname = 'Pentagram of Protection'
    qc.self.effects |= defs.EF_RED
    qc.self.items = defs.IT_INVULNERABILITY
    qc.setsize(qc.self, Vector(-16, -16, -24), Vector(16, 16, 32))
    StartItem()
    
# QUAKED item_artifact_envirosuit (0 .5 .8) (-16 -16 -24) (16 16 32)
# Player takes no damage from water or slime for 30 seconds
# 

def item_artifact_envirosuit(*qwp_extra):
    qc.self.touch = powerup_touch
    engine.precache_model('progs/suit.mdl')
    engine.precache_sound('items/suit.wav')
    engine.precache_sound('items/suit2.wav')
    qc.self.noise = 'items/suit.wav'
    qc.self.setmodel('progs/suit.mdl')
    qc.self.netname = 'Biosuit'
    qc.self.items = defs.IT_SUIT
    qc.setsize(qc.self, Vector(-16, -16, -24), Vector(16, 16, 32))
    StartItem()
    
# QUAKED item_artifact_invisibility (0 .5 .8) (-16 -16 -24) (16 16 32)
# Player is invisible for 30 seconds
# 

def item_artifact_invisibility(*qwp_extra):
    qc.self.touch = powerup_touch
    engine.precache_model('progs/invisibl.mdl')
    engine.precache_sound('items/inv1.wav')
    engine.precache_sound('items/inv2.wav')
    engine.precache_sound('items/inv3.wav')
    qc.self.noise = 'items/inv1.wav'
    qc.self.setmodel('progs/invisibl.mdl')
    qc.self.netname = 'Ring of Shadows'
    qc.self.items = defs.IT_INVISIBILITY
    qc.setsize(qc.self, Vector(-16, -16, -24), Vector(16, 16, 32))
    StartItem()
    
# QUAKED item_artifact_super_damage (0 .5 .8) (-16 -16 -24) (16 16 32)
# The next attack from the player will do 4x damage
# 

def item_artifact_super_damage(*qwp_extra):
    qc.self.touch = powerup_touch
    engine.precache_model('progs/quaddama.mdl')
    engine.precache_sound('items/damage.wav')
    engine.precache_sound('items/damage2.wav')
    engine.precache_sound('items/damage3.wav')
    qc.self.noise = 'items/damage.wav'
    qc.self.setmodel('progs/quaddama.mdl')
    if defs.deathmatch == 4:
        qc.self.netname = 'OctaPower'
    else:
        qc.self.netname = 'Quad Damage'
    qc.self.items = defs.IT_QUAD
    qc.self.effects |= defs.EF_BLUE
    qc.setsize(qc.self, Vector(-16, -16, -24), Vector(16, 16, 32))
    StartItem()
    
# 
# ===============================================================================
# 
# PLAYER BACKPACKS
# 
# ===============================================================================
# 

def BackpackTouch(*qwp_extra):
    s = None
    best = 0
    old = 0
    new = 0
    stemp = engine.world
    acount = 0
    b_switch = 0
    if defs.deathmatch == 4:
        if qc.other.invincible_time > 0:
            return 
    if (qc.stof(qc.other.infokey('b_switch'))) == 0:
        b_switch = 8
    else:
        b_switch = qc.stof(qc.other.infokey('b_switch'))
    if qc.other.classname != 'player':
        return 
    if qc.other.health <= 0:
        return 
    acount = 0
    qc.other.sprint(defs.PRINT_LOW, 'You get ')
    if defs.deathmatch == 4:
        qc.other.health += 10
        qc.other.sprint(defs.PRINT_LOW, '10 additional health\012')
        if (qc.other.health > 250) and (qc.other.health < 300):
            qc.other.sound(defs.CHAN_ITEM, 'items/protect3.wav', 1, defs.ATTN_NORM)
        else:
            qc.other.sound(defs.CHAN_ITEM, 'weapons/lock4.wav', 1, defs.ATTN_NORM)
        qc.other.stuffcmd('bf\012')
        qc.self.remove()
        if qc.other.health > 299:
            if qc.other.invincible_time != 1:
                qc.other.invincible_time = 1
                qc.other.invincible_finished = qc.time + 30
                qc.other.items |= defs.IT_INVULNERABILITY
                qc.other.super_time = 1
                qc.other.super_damage_finished = qc.time + 30
                qc.other.items |= defs.IT_QUAD
                qc.other.ammo_cells = 0
                qc.other.sound(defs.CHAN_VOICE, 'boss1/sight1.wav', 1, defs.ATTN_NORM)
                qc.other.stuffcmd('bf\012')
                engine.bprint(defs.PRINT_HIGH, qc.other.netname)
                engine.bprint(defs.PRINT_HIGH, ' attains bonus powers!!!\012')
                
            
        qc.self = qc.other
        return 
        
    if qc.self.items:
        if (qc.other.items & qc.self.items) == 0:
            acount = 1
            qc.other.sprint(defs.PRINT_LOW, 'the ')
            qc.other.sprint(defs.PRINT_LOW, qc.self.netname)
            
    #  if the player was using his best weapon, change up to the new one if better          
    stemp = qc.self
    qc.self = qc.other
    best = weapons.W_BestWeapon()
    qc.self = stemp
    #  change weapons
    qc.other.ammo_shells += qc.self.ammo_shells
    qc.other.ammo_nails += qc.self.ammo_nails
    qc.other.ammo_rockets += qc.self.ammo_rockets
    qc.other.ammo_cells += qc.self.ammo_cells
    new = qc.self.items
    if not new:
        new = qc.other.weapon
    old = qc.other.items
    qc.other.items |= qc.self.items
    bound_other_ammo()
    if qc.self.ammo_shells:
        if acount:
            qc.other.sprint(defs.PRINT_LOW, ', ')
        acount = 1
        s = str(qc.self.ammo_shells)
        qc.other.sprint(defs.PRINT_LOW, s)
        qc.other.sprint(defs.PRINT_LOW, ' shells')
        
    if qc.self.ammo_nails:
        if acount:
            qc.other.sprint(defs.PRINT_LOW, ', ')
        acount = 1
        s = str(qc.self.ammo_nails)
        qc.other.sprint(defs.PRINT_LOW, s)
        qc.other.sprint(defs.PRINT_LOW, ' nails')
        
    if qc.self.ammo_rockets:
        if acount:
            qc.other.sprint(defs.PRINT_LOW, ', ')
        acount = 1
        s = str(qc.self.ammo_rockets)
        qc.other.sprint(defs.PRINT_LOW, s)
        qc.other.sprint(defs.PRINT_LOW, ' rockets')
        
    if qc.self.ammo_cells:
        if acount:
            qc.other.sprint(defs.PRINT_LOW, ', ')
        acount = 1
        s = str(qc.self.ammo_cells)
        qc.other.sprint(defs.PRINT_LOW, s)
        qc.other.sprint(defs.PRINT_LOW, ' cells')
        
    if (defs.deathmatch == 3 or defs.deathmatch == 5) & ((WeaponCode(new) == 6) or (WeaponCode(new) == 7)) & (qc.other.ammo_rockets < 5):
        qc.other.ammo_rockets = 5
    qc.other.sprint(defs.PRINT_LOW, '\012')
    #  backpack touch sound
    qc.other.sound(defs.CHAN_ITEM, 'weapons/lock4.wav', 1, defs.ATTN_NORM)
    qc.other.stuffcmd('bf\012')
    qc.self.remove()
    qc.self = qc.other
    #  change to the weapon
    if WeaponCode(new) <= b_switch:
        if qc.self.flags & defs.FL_INWATER:
            if new != defs.IT_LIGHTNING:
                Deathmatch_Weapon(old, new)
                
            
        else:
            Deathmatch_Weapon(old, new)
            
        
    weapons.W_SetCurrentAmmo()
    
# 
# ===============
# DropBackpack
# ===============
# 

def DropBackpack(*qwp_extra):
    item = engine.world
    if not (qc.self.ammo_shells + qc.self.ammo_nails + qc.self.ammo_rockets + qc.self.ammo_cells):
        return  #  nothing in it
    item = qc.spawn()
    item.origin = qc.self.origin - Vector(0, 0, 24)
    item.items = qc.self.weapon
    if item.items == defs.IT_AXE:
        item.netname = 'Axe'
    elif item.items == defs.IT_SHOTGUN:
        item.netname = 'Shotgun'
    elif item.items == defs.IT_SUPER_SHOTGUN:
        item.netname = 'Double-barrelled Shotgun'
    elif item.items == defs.IT_NAILGUN:
        item.netname = 'Nailgun'
    elif item.items == defs.IT_SUPER_NAILGUN:
        item.netname = 'Super Nailgun'
    elif item.items == defs.IT_GRENADE_LAUNCHER:
        item.netname = 'Grenade Launcher'
    elif item.items == defs.IT_ROCKET_LAUNCHER:
        item.netname = 'Rocket Launcher'
    elif item.items == defs.IT_LIGHTNING:
        item.netname = 'Thunderbolt'
    else:
        item.netname = None
    item.ammo_shells = qc.self.ammo_shells
    item.ammo_nails = qc.self.ammo_nails
    item.ammo_rockets = qc.self.ammo_rockets
    item.ammo_cells = qc.self.ammo_cells
    item.velocity %= Vector(None, None, 300)
    item.velocity %= Vector(-100 + (random.random() * 200), None, None)
    item.velocity %= Vector(None, -100 + (random.random() * 200), None)
    item.flags = defs.FL_ITEM
    item.solid = defs.SOLID_TRIGGER
    item.movetype = defs.MOVETYPE_TOSS
    item.setmodel('progs/backpack.mdl')
    qc.setsize(item, Vector(-16, -16, 0), Vector(16, 16, 56))
    item.touch = BackpackTouch
    item.nextthink = qc.time + 120 #  remove after 2 minutes
    item.think = subs.SUB_Remove
    


def qwp_reset_items(*qwp_extra):
    global H_ROTTEN
    global H_MEGA
    global WEAPON_BIG2
    global WEAPON_SHOTGUN
    global WEAPON_ROCKET
    global WEAPON_SPIKES
    global WEAPON_BIG
    H_ROTTEN = 1
    H_MEGA = 2
    WEAPON_BIG2 = 1
    WEAPON_SHOTGUN = 1
    WEAPON_ROCKET = 2
    WEAPON_SPIKES = 4
    WEAPON_BIG = 8
