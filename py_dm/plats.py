###
### Generated by QuakeC -> Python translator
### Id: qc2python.py,v 1.5 2001/02/05 21:15:44 barryp Exp 
###
from qwpython.qwsv import engine, Vector
from qwpython.qcsupport import qc

import defs
import subs
import combat

PLAT_LOW_TRIGGER = 1

def plat_spawn_inside_trigger(*qwp_extra):
    trigger = engine.world
    tmin = Vector(0, 0, 0)
    tmax = Vector(0, 0, 0)
    # 
    #  middle trigger
    # 	
    trigger = qc.spawn()
    trigger.touch = plat_center_touch
    trigger.movetype = defs.MOVETYPE_NONE
    trigger.solid = defs.SOLID_TRIGGER
    trigger.enemy = qc.self
    tmin = qc.self.mins + Vector(25, 25, 0)
    tmax = qc.self.maxs - Vector(25, 25, -8)
    tmin %= Vector(None, None, tmax.z - (qc.self.pos1.z - qc.self.pos2.z + 8))
    if qc.self.spawnflags & PLAT_LOW_TRIGGER:
        tmax %= Vector(None, None, tmin.z + 8)
    if qc.self.size.x <= 50:
        tmin %= Vector((qc.self.mins.x + qc.self.maxs.x) / 2, None, None)
        tmax %= Vector(tmin.x + 1, None, None)
        
    if qc.self.size.y <= 50:
        tmin %= Vector(None, (qc.self.mins.y + qc.self.maxs.y) / 2, None)
        tmax %= Vector(None, tmin.y + 1, None)
        
    qc.setsize(trigger, tmin, tmax)
    

def plat_hit_top(*qwp_extra):
    qc.self.sound(defs.CHAN_NO_PHS_ADD + defs.CHAN_VOICE, qc.self.noise1, 1, defs.ATTN_NORM)
    qc.self.state = defs.STATE_TOP
    qc.self.think = plat_go_down
    qc.self.nextthink = qc.self.ltime + 3
    

def plat_hit_bottom(*qwp_extra):
    qc.self.sound(defs.CHAN_NO_PHS_ADD + defs.CHAN_VOICE, qc.self.noise1, 1, defs.ATTN_NORM)
    qc.self.state = defs.STATE_BOTTOM
    

def plat_go_down(*qwp_extra):
    qc.self.sound(defs.CHAN_VOICE, qc.self.noise, 1, defs.ATTN_NORM)
    qc.self.state = defs.STATE_DOWN
    subs.SUB_CalcMove(qc.self.pos2, qc.self.speed, plat_hit_bottom)
    

def plat_go_up(*qwp_extra):
    qc.self.sound(defs.CHAN_VOICE, qc.self.noise, 1, defs.ATTN_NORM)
    qc.self.state = defs.STATE_UP
    subs.SUB_CalcMove(qc.self.pos1, qc.self.speed, plat_hit_top)
    

def plat_center_touch(*qwp_extra):
    if qc.other.classname != 'player':
        return 
    if qc.other.health <= 0:
        return 
    qc.self = qc.self.enemy
    if qc.self.state == defs.STATE_BOTTOM:
        plat_go_up()
    elif qc.self.state == defs.STATE_TOP:
        qc.self.nextthink = qc.self.ltime + 1 #  delay going down
    

def plat_outside_touch(*qwp_extra):
    if qc.other.classname != 'player':
        return 
    if qc.other.health <= 0:
        return 
    # dprint ("plat_outside_touch\n");
    qc.self = qc.self.enemy
    if qc.self.state == defs.STATE_TOP:
        plat_go_down()
    

def plat_trigger_use(*qwp_extra):
    if qc.self.think:
        return  #  allready activated
    plat_go_down()
    

def plat_crush(*qwp_extra):
    # dprint ("plat_crush\n");
    qc.other.deathtype = 'squish'
    combat.T_Damage(qc.other, qc.self, qc.self, 1)
    if qc.self.state == defs.STATE_UP:
        plat_go_down()
    elif qc.self.state == defs.STATE_DOWN:
        plat_go_up()
    else:
        qc.objerror('plat_crush: bad self.state\012')
    

def plat_use(*qwp_extra):
    qc.self.use = subs.SUB_Null
    if qc.self.state != defs.STATE_UP:
        qc.objerror('plat_use: not in up state')
    plat_go_down()
    
# QUAKED func_plat (0 .5 .8) ? PLAT_LOW_TRIGGER
# speed	default 150
# 
# Plats are always drawn in the extended position, so they will light correctly.
# 
# If the plat is the target of another trigger or button, it will start out disabled in the extended position until it is trigger, when it will lower and become a normal plat.
# 
# If the "height" key is set, that will determine the amount the plat moves, instead of being implicitly determined by the model's height.
# Set "sounds" to one of the following:
# 1) base fast
# 2) chain slow
# 

def func_plat(*qwp_extra):
    t = engine.world
    if not qc.self.t_length:
        qc.self.t_length = 80
    if not qc.self.t_width:
        qc.self.t_width = 10
    if qc.self.sounds == 0:
        qc.self.sounds = 2
    #  FIX THIS TO LOAD A GENERIC PLAT SOUND
    if qc.self.sounds == 1:
        engine.precache_sound('plats/plat1.wav')
        engine.precache_sound('plats/plat2.wav')
        qc.self.noise = 'plats/plat1.wav'
        qc.self.noise1 = 'plats/plat2.wav'
        
    if qc.self.sounds == 2:
        engine.precache_sound('plats/medplat1.wav')
        engine.precache_sound('plats/medplat2.wav')
        qc.self.noise = 'plats/medplat1.wav'
        qc.self.noise1 = 'plats/medplat2.wav'
        
    qc.self.mangle = qc.self.angles
    qc.self.angles = Vector(0, 0, 0)
    qc.self.classname = 'plat'
    qc.self.solid = defs.SOLID_BSP
    qc.self.movetype = defs.MOVETYPE_PUSH
    qc.setorigin(qc.self, qc.self.origin)
    qc.self.setmodel(qc.self.model)
    qc.setsize(qc.self, qc.self.mins, qc.self.maxs)
    qc.self.blocked = plat_crush
    if not qc.self.speed:
        qc.self.speed = 150
    #  pos1 is the top position, pos2 is the bottom
    qc.self.pos1 = qc.self.origin
    qc.self.pos2 = qc.self.origin
    if qc.self.height:
        qc.self.pos2 %= Vector(None, None, qc.self.origin.z - qc.self.height)
    else:
        qc.self.pos2 %= Vector(None, None, qc.self.origin.z - qc.self.size.z + 8)
    qc.self.use = plat_trigger_use
    plat_spawn_inside_trigger() #  the "start moving" trigger	
    if qc.self.targetname:
        qc.self.state = defs.STATE_UP
        qc.self.use = plat_use
        
    else:
        qc.setorigin(qc.self, qc.self.pos2)
        qc.self.state = defs.STATE_BOTTOM
        
    
# ============================================================================

def train_blocked(*qwp_extra):
    if qc.time < qc.self.attack_finished:
        return 
    qc.self.attack_finished = qc.time + 0.5
    qc.other.deathtype = 'squish'
    combat.T_Damage(qc.other, qc.self, qc.self, qc.self.dmg)
    

def train_use(*qwp_extra):
    if qc.self.think != func_train_find:
        return  #  already activated
    train_next()
    

def train_wait(*qwp_extra):
    if qc.self.wait:
        qc.self.nextthink = qc.self.ltime + qc.self.wait
        qc.self.sound(defs.CHAN_NO_PHS_ADD + defs.CHAN_VOICE, qc.self.noise, 1, defs.ATTN_NORM)
        
    else:
        qc.self.nextthink = qc.self.ltime + 0.1
    qc.self.think = train_next
    

def train_next(*qwp_extra):
    targ = engine.world
    targ = qc.find(qc.world, 'targetname', qc.self.target)
    qc.self.target = targ.target
    if not qc.self.target:
        qc.objerror('train_next: no next target')
    if targ.wait:
        qc.self.wait = targ.wait
    else:
        qc.self.wait = 0
    qc.self.sound(defs.CHAN_VOICE, qc.self.noise1, 1, defs.ATTN_NORM)
    subs.SUB_CalcMove(targ.origin - qc.self.mins, qc.self.speed, train_wait)
    

def func_train_find(*qwp_extra):
    targ = engine.world
    targ = qc.find(qc.world, 'targetname', qc.self.target)
    qc.self.target = targ.target
    qc.setorigin(qc.self, targ.origin - qc.self.mins)
    if not qc.self.targetname:
        #  not triggered, so start immediately
        qc.self.nextthink = qc.self.ltime + 0.1
        qc.self.think = train_next
        
    
# QUAKED func_train (0 .5 .8) ?
# Trains are moving platforms that players can ride.
# The targets origin specifies the min point of the train at each corner.
# The train spawns at the first target it is pointing at.
# If the train is the target of a button or trigger, it will not begin moving until activated.
# speed	default 100
# dmg		default	2
# sounds
# 1) ratchet metal
# 
# 

def func_train(*qwp_extra):
    if not qc.self.speed:
        qc.self.speed = 100
    if not qc.self.target:
        qc.objerror('func_train without a target')
    if not qc.self.dmg:
        qc.self.dmg = 2
    if qc.self.sounds == 0:
        qc.self.noise = ('misc/null.wav')
        engine.precache_sound('misc/null.wav')
        qc.self.noise1 = ('misc/null.wav')
        engine.precache_sound('misc/null.wav')
        
    if qc.self.sounds == 1:
        qc.self.noise = ('plats/train2.wav')
        engine.precache_sound('plats/train2.wav')
        qc.self.noise1 = ('plats/train1.wav')
        engine.precache_sound('plats/train1.wav')
        
    qc.self.cnt = 1
    qc.self.solid = defs.SOLID_BSP
    qc.self.movetype = defs.MOVETYPE_PUSH
    qc.self.blocked = train_blocked
    qc.self.use = train_use
    qc.self.classname = 'train'
    qc.self.setmodel(qc.self.model)
    qc.setsize(qc.self, qc.self.mins, qc.self.maxs)
    qc.setorigin(qc.self, qc.self.origin)
    #  start trains on the second frame, to make sure their targets have had
    #  a chance to spawn
    qc.self.nextthink = qc.self.ltime + 0.1
    qc.self.think = func_train_find
    
# QUAKED misc_teleporttrain (0 .5 .8) (-8 -8 -8) (8 8 8)
# This is used for the final bos
# 

def misc_teleporttrain(*qwp_extra):
    if not qc.self.speed:
        qc.self.speed = 100
    if not qc.self.target:
        qc.objerror('func_train without a target')
    qc.self.cnt = 1
    qc.self.solid = defs.SOLID_NOT
    qc.self.movetype = defs.MOVETYPE_PUSH
    qc.self.blocked = train_blocked
    qc.self.use = train_use
    qc.self.avelocity = Vector(100, 200, 300)
    qc.self.noise = ('misc/null.wav')
    engine.precache_sound('misc/null.wav')
    qc.self.noise1 = ('misc/null.wav')
    engine.precache_sound('misc/null.wav')
    engine.precache_model('progs/teleport.mdl')
    qc.self.setmodel('progs/teleport.mdl')
    qc.setsize(qc.self, qc.self.mins, qc.self.maxs)
    qc.setorigin(qc.self, qc.self.origin)
    #  start trains on the second frame, to make sure their targets have had
    #  a chance to spawn
    qc.self.nextthink = qc.self.ltime + 0.1
    qc.self.think = func_train_find
    


def qwp_reset_plats(*qwp_extra):
    global PLAT_LOW_TRIGGER
    PLAT_LOW_TRIGGER = 1
