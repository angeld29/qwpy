###
### Generated by QuakeC -> Python translator
### Id: qc2python.py,v 1.5 2001/02/05 21:15:44 barryp Exp 
###
### 2001-02-10  Tweaked the translated code to not cycle
###             through ctf2m4 and ctf2m6, which the engine
###             has problems with (barryp)
###
### 2001-02-17  Cleaned up translation a bit. ClientObituary is
###             a real bitch, and could still be looked at (barryp)
###
from qwpython.qwsv import engine, Vector
from qwpython.qcsupport import qc

import defs
import teamplay
import random
import subs
import ctfgame
import world
import items
import player
import telefrag
import weapons
import triggers
import status
import combat
import grapple

#  prototypes
modelindex_eyes = 0
modelindex_player = 0
pregameover = 0

#  ZOID: with several effects doing the dimlight thing, they just can't
#  turn it off.  Do not set self.effects with EF_DIMLIGHT directly.  This
#  will automatically do it when CheckPowerups is called
#  EF_DIMLIGHT is used;
#  1. Invincible (Pentagram)
#  2. Super Damage (Quad Power)
#  3. Having Flag in Capture
#  self is player
#
def CheckDimLight(*qwp_extra):
    flag = 0

    #  invincible
    if qc.self.invincible_finished > qc.time:
        flag = 1
    #  quad
    if qc.self.super_damage_finished > qc.time:
        flag = 1
    #  flag
    if qc.self.player_flag & defs.ITEM_ENEMY_FLAG:
        flag = 1

    if flag:
        qc.self.effects |= defs.EF_DIMLIGHT
    else:
        qc.self.effects -= qc.self.effects & defs.EF_DIMLIGHT

    
# 
# =============================================================================
# 
# 				LEVEL CHANGING / INTERMISSION
# 
# =============================================================================
# 
nextmap = None
intermission_running = 0
intermission_exittime = 0

#
# QUAKED info_intermission (1 0.5 0.5) (-16 -16 -16) (16 16 16)
# This is the camera point for the intermission.
# Use mangle instead of angle, so you can set pitch or roll as well as yaw.  'pitch roll yaw'
# 
def info_intermission(*qwp_extra):
    pass

def SetChangeParms(*qwp_extra):
    if qc.self.health <= 0:
        SetNewParms()
        if defs.gamestart:
            qc.parm10 = -1
        else:
            qc.parm10 = qc.self.steam #  Save the current team of the player
        qc.parm14 = qc.self.statstate
        return 
        
    #  remove items
    qc.self.items -= qc.self.items & (defs.IT_KEY1 | defs.IT_KEY2 | defs.IT_INVISIBILITY | defs.IT_INVULNERABILITY | defs.IT_SUIT | defs.IT_QUAD)
    #  cap super health
    if qc.self.health > 100:
        qc.self.health = 100
    if qc.self.health < 50:
        qc.self.health = 50
    SetNewParms()
    #  *TEAMPLAY*
    if defs.gamestart:
        qc.parm10 = -1
    else:
        qc.parm10 = qc.self.steam #  Save the current team of the player
    qc.parm14 = qc.self.statstate
    qc.parm16 = qc.self.player_flag
    

def SetNewParms(*qwp_extra):
    if defs.gamestart and not pregameover:
        qc.parm1 = defs.IT_AXE
        qc.parm2 = 100
        qc.parm4 = 0
        qc.parm8 = defs.IT_AXE
        qc.parm10 = 1        
    else:
        if engine.cvar('teamplay') & teamplay.TEAM_DISABLE_GRAPPLE:
            qc.parm1 = defs.IT_SHOTGUN | defs.IT_AXE
        else:
            qc.parm1 = defs.IT_SHOTGUN | defs.IT_AXE | defs.IT_GRAPPLE
        qc.parm2 = 100
        qc.parm3 = 50
        qc.parm9 = 30
        qc.parm1 += defs.IT_ARMOR1
        qc.parm4 = 40
        qc.parm8 = defs.IT_SHOTGUN
        qc.parm10 = -1 #  Reset 
        
    qc.parm5 = 0
    qc.parm6 = 0
    qc.parm7 = 0
    qc.parm8 = defs.IT_SHOTGUN
    #  *TEAMPLAY*
    qc.parm10 = -1 #  Reset 
    qc.parm14 = qc.self.statstate
    qc.parm16 = 0
    

def DecodeLevelParms(*qwp_extra):
    qc.self.player_flag |= qc.parm16
    qc.self.player_flag -= qc.self.player_flag & defs.ITEM_RUNE_MASK
    qc.self.player_flag -= qc.self.player_flag & defs.ITEM_ENEMY_FLAG
    qc.self.statstate = qc.parm14
    if defs.gamestart:
        SetNewParms() #  take away all stuff on starting new episode
        qc.self.ctfskinno = 0        
    else:
        qc.self.ctfskinno = (qc.self.player_flag & 65280) / 256
        teamplay.TeamSkinSet()
        
    qc.self.items = qc.parm1
    qc.self.health = qc.parm2
    qc.self.armorvalue = qc.parm3
    qc.self.ammo_shells = qc.parm4
    qc.self.ammo_nails = qc.parm5
    qc.self.ammo_rockets = qc.parm6
    qc.self.ammo_cells = qc.parm7
    qc.self.weapon = qc.parm8
    qc.self.armortype = qc.parm9 * 0.01
    #  *XXX* EXPERT CTF
    #  Reset times for additional scoring system on level change and server join
    #  dprint("decode level parms\n");
    qc.self.last_returned_flag = -10
    qc.self.last_fragged_carrier = -10
    qc.self.flag_since = -10
    qc.self.last_hurt_carrier = -10
    #  *TEAMPLAY*
    if teamplay.TeamColorIsLegal(qc.parm10):
        qc.self.steam = qc.parm10

    
# 
# ============
# FindIntermission
# 
# Returns the entity to view from
# ============
# 
def FindIntermission(*qwp_extra):
    #  look for info_intermission first
    spot = qc.find(qc.world, 'classname', 'info_intermission')
    if spot:
        #  pick a random one
        cyc = random.random() * 4
        while cyc > 1:
            spot = qc.find(spot, 'classname', 'info_intermission')
            if not spot:
                spot = qc.find(spot, 'classname', 'info_intermission')
            cyc -= 1            
        return spot
        
    #  then look for the start position
    spot = qc.find(qc.world, 'classname', 'info_player_start')
    if spot:
        return spot
    qc.objerror('FindIntermission: no spot')
    

def GotoNextMap(*qwp_extra):
    global nextmap

    if engine.cvar('samelevel'): #  if samelevel is set, stay on same level
        engine.changelevel(qc.mapname)
    else:
        # FIXME special case for now
        if nextmap == 'end':
            nextmap = 'dm1'
        elif nextmap == 'ctf9':
            nextmap = 'ctf2m1'
        engine.changelevel(nextmap)
        
    
# 
# ============
# IntermissionThink
# 
# When the player presses attack or jump, change to the next level
# ============
# 
def IntermissionThink(*qwp_extra):
    if qc.time < intermission_exittime:
        return 
    if not qc.self.button0 and not qc.self.button1 and not qc.self.button2:
        return 
    GotoNextMap()

    
# 
# ============
# execute_changelevel
# 
# The global "nextmap" has been set previously.
# Take the players to the intermission spot
# ============
# 
def execute_changelevel(*qwp_extra):
    global intermission_running
    global intermission_exittime

    intermission_running = 1
    #  enforce a wait time before allowing changelevel
    intermission_exittime = qc.time + 8
    pos = FindIntermission()
    #  play intermission music
    qc.WriteByte(defs.MSG_ALL, defs.SVC_CDTRACK)
    qc.WriteByte(defs.MSG_ALL, 3)
    qc.WriteByte(defs.MSG_ALL, defs.SVC_INTERMISSION)
    qc.WriteCoord(defs.MSG_ALL, pos.origin.x)
    qc.WriteCoord(defs.MSG_ALL, pos.origin.y)
    qc.WriteCoord(defs.MSG_ALL, pos.origin.z)
    qc.WriteAngle(defs.MSG_ALL, pos.mangle.x)
    qc.WriteAngle(defs.MSG_ALL, pos.mangle.y)
    qc.WriteAngle(defs.MSG_ALL, pos.mangle.z)
    qc.other = qc.find(qc.world, 'classname', 'player')
    while qc.other != qc.world:
        qc.other.takedamage = defs.DAMAGE_NO
        qc.other.solid = defs.SOLID_NOT
        qc.other.movetype = defs.MOVETYPE_NONE
        qc.other.modelindex = 0
        qc.other = qc.find(qc.other, 'classname', 'player')
        
    
def changelevel_touch(*qwp_extra):
    global nextmap

    if qc.other.classname != 'player':
        return 
    #  if "noexit" is set, blow up the player trying to leave
    if defs.teamplay & teamplay.TEAM_CAPTURE_FLAG:
        return 
    if (engine.cvar('samelevel') == 2) or ((engine.cvar('samelevel') == 3) and not defs.gamestart):
        return  #  do nothing
    engine.bprint(defs.PRINT_HIGH, qc.other.netname)
    engine.bprint(defs.PRINT_HIGH, ' exited the level\012')
    nextmap = qc.self.map
    subs.SUB_UseTargets()
    qc.self.touch = subs.SUB_Null
    #  we can't move people right now, because touch functions are called
    #  in the middle of C movement code, so set a think time to do it
    qc.self.think = execute_changelevel
    qc.self.nextthink = qc.time + 0.1

    
# QUAKED trigger_changelevel (0.5 0.5 0.5) ? NO_INTERMISSION
# When the player touches this, he gets sent to the map listed in the "map" variable.  Unless the NO_INTERMISSION flag is set, the view will go to the info_intermission spot and display stats.
# 
def trigger_changelevel(*qwp_extra):
    if defs.gamestart:
        if qc.self.map == 'e1m1':
            qc.self.message = 'E1 Dimension of the Doomed'
        elif qc.self.map == 'e2m1':
            qc.self.message = 'E2 The Realm of Black Magic'
        elif qc.self.map == 'e3m1':
            qc.self.message = 'E3 The Netherworld'
        elif qc.self.map == 'e4m1':
            qc.self.message = 'E4 The Elder World'
        elif qc.self.map == 'end':
            qc.self.message = 'The Deathmatch Arenas'
        else:
            qc.self.message = 'Unknown'
        qc.self.classname = 'trigger_voteexit'
        ctfgame.trigger_voteexit()
        return 
        
    if not qc.self.map:
        qc.objerror("chagnelevel trigger doesn't have map")
    subs.InitTrigger()
    qc.self.touch = changelevel_touch

    
# 
# =============================================================================
# 
# 				PLAYER GAME EDGE FUNCTIONS
# 
# =============================================================================
# 
#  called by ClientKill and DeadThink
#
def respawn(*qwp_extra):
    #  make a copy of the dead body for appearances sake
    world.CopyToBodyQue(qc.self)
    #  set default spawn parms
    SetNewParms()
    #  respawn		
    PutClientInServer()
 
    
# 
# ============
# ClientKill
# 
# Player entered the suicide command
# ============
# 
def ClientKill(*qwp_extra):
    if defs.gamestart:
        qc.self.sprint(defs.PRINT_HIGH, 'Life just started.\012')
        return 
        
    if qc.self.suicide_count > 3:
        qc.self.sprint(defs.PRINT_HIGH, 'You have suicided too much already.\012')
        return 
        
    engine.bprint(defs.PRINT_MEDIUM, qc.self.netname)
    engine.bprint(defs.PRINT_MEDIUM, ' suicides\012')
    items.DropRune()
    teamplay.TeamCaptureDropFlagOfPlayer(qc.self)
    player.set_suicide_frame()
    qc.self.modelindex = modelindex_player
    qc.self.logfrag(qc.self)
    qc.self.frags -= 2 #  extra penalty
    qc.self.suicide_count += 1
    respawn()
    

def CheckSpawnPoint(v, *qwp_extra):
    return defs.FALSE

    
# 
# ============
# SelectSpawnPoint
# 
# Returns the entity to spawn at
# ============
# 
def SelectSpawnPoint(*qwp_extra):
    #  testinfo_player_start is only found in regioned levels
    spot = qc.find(qc.world, 'classname', 'testplayerstart')
    if spot:
        return spot
    #  choose a info_player_deathmatch point
    # CTF spawns
    if not qc.self.killed:
        spot = teamplay.TeamCaptureSpawn()
        if spot != qc.world:
            return spot        
    elif defs.gamestart and qc.self.killed:
        ctfgame.lastvotespawn = qc.find(ctfgame.lastvotespawn, 'classname', 'info_vote_destination')
        if ctfgame.lastvotespawn == qc.world:
            ctfgame.lastvotespawn = qc.find(ctfgame.lastvotespawn, 'classname', 'info_vote_destination')
        return ctfgame.lastvotespawn
        
    world.lastspawn = qc.find(world.lastspawn, 'classname', 'info_player_deathmatch')
    if world.lastspawn == qc.world:
        world.lastspawn = qc.find(world.lastspawn, 'classname', 'info_player_deathmatch')
    if world.lastspawn != qc.world:
        return world.lastspawn
    spot = qc.find(qc.world, 'classname', 'info_player_start')
    if not spot:
        qc.error('PutClientInServer: no info_player_start on level')
    return spot

    
# 
# ===========
# ValidateUser
# 
# 
# ============
# 
def ValidateUser(e, *qwp_extra):
    pass
    
    
# 
# ===========
# PutClientInServer
# 
# called each time a player enters a new level
# ============
# 
def PutClientInServer(*qwp_extra):
    global modelindex_eyes
    global modelindex_player

    qc.serverflags = 0 #  make sure
    qc.self.classname = 'player'
    qc.self.health = 100
    qc.self.takedamage = defs.DAMAGE_AIM
    qc.self.solid = defs.SOLID_SLIDEBOX
    qc.self.movetype = defs.MOVETYPE_WALK
    qc.self.show_hostile = 0
    qc.self.max_health = 100
    qc.self.flags = defs.FL_CLIENT
    qc.self.air_finished = qc.time + 12
    qc.self.dmg = 2 #  initial water damage
    qc.self.super_damage_finished = 0
    qc.self.radsuit_finished = 0
    qc.self.invisible_finished = 0
    qc.self.invincible_finished = 0
    qc.self.effects = 0
    qc.self.invincible_time = 0
    qc.self.staydeadtime = 0
    qc.self.regen_time = 0
    qc.self.rune_notice_time = 0
    qc.self.last_hurt_carrier = -10
    DecodeLevelParms()
    spot = SelectSpawnPoint()
    # ZOID: Minimize chance of telefragging someone, from Johannes Plass
    # (plass@dipmza.physik.uni-mainz.de) ServerModules package
    spot = telefrag.TelefragSelectSpawnPoint(spot)
    weapons.W_SetCurrentAmmo()
    qc.self.attack_finished = qc.time
    qc.self.th_pain = player.player_pain
    qc.self.th_die = player.PlayerDie
    spd = engine.cvar('sv_maxspeed')
    if qc.self.maxspeed != spd:
        qc.self.maxspeed = spd
    qc.self.deadflag = defs.DEAD_NO
    #  paustime is set by teleporters to keep the player from moving a while
    qc.self.pausetime = 0
    # 	spot = SelectSpawnPoint ();
    qc.self.origin = spot.origin + Vector(0, 0, 1)
    qc.self.angles = spot.angles
    qc.self.fixangle = defs.TRUE #  turn this way immediately
    #  oh, this is a hack!
    qc.self.setmodel('progs/eyes.mdl')
    modelindex_eyes = qc.self.modelindex
    qc.self.setmodel('progs/player.mdl')
    modelindex_player = qc.self.modelindex
    qc.setsize(qc.self, defs.VEC_HULL_MIN, defs.VEC_HULL_MAX)
    qc.self.view_ofs = Vector(0, 0, 22)
    qc.self.velocity = Vector(0, 0, 0)
    player.player_stand1()
    qc.makevectors(qc.self.angles)
    triggers.spawn_tfog(qc.self.origin + qc.v_forward * 20)
    triggers.spawn_tdeath(qc.self.origin, qc.self)
    #  grapple stuff
    qc.self.on_hook = defs.FALSE
    qc.self.hook_out = defs.FALSE

    
# 
# =============================================================================
# 
# 				QUAKED FUNCTIONS
# 
# =============================================================================
# 
# QUAKED info_player_start (1 0 0) (-16 -16 -24) (16 16 24)
# The normal starting point for a level.
# 
def info_player_start(*qwp_extra):
    pass
    
    
# QUAKED info_player_start2 (1 0 0) (-16 -16 -24) (16 16 24)
# Only used on start map for the return point from an episode.
# 
def info_player_start2(*qwp_extra):
    pass
    
    
# QUAKED info_player_deathmatch (1 0 1) (-16 -16 -24) (16 16 24)
# potential spawning position for deathmatch games
# 
def info_player_deathmatch(*qwp_extra):
    if defs.deathmatch:
        items.StartRuneSpawn()

    
# QUAKED info_player_coop (1 0 1) (-16 -16 -24) (16 16 24)
# potential spawning position for coop games
# 
def info_player_coop(*qwp_extra):
    pass
    
    
# 
# ===============================================================================
# 
# RULES
# 
# ===============================================================================
# 
# 
# go to the next level for deathmatch
# only called if a time or frag limit has expired
# 
def NextLevel(*qwp_extra):
    global nextmap
    
    #  episode one
    if qc.mapname == 'e1m1':
        nextmap = 'e1m2'
    elif qc.mapname == 'e1m2':
        nextmap = 'e1m3'
    elif qc.mapname == 'e1m3':
        nextmap = 'e1m4'
    elif qc.mapname == 'e1m4':
        nextmap = 'e1m5'
    elif qc.mapname == 'e1m5':
        nextmap = 'e1m6'
    elif qc.mapname == 'e1m6':
        nextmap = 'ctfstart'
    #  episode two
    elif qc.mapname == 'e2m1':
        nextmap = 'e2m2'
    elif qc.mapname == 'e2m2':
        nextmap = 'e2m3'
    elif qc.mapname == 'e2m3':
        nextmap = 'e2m4'
    elif qc.mapname == 'e2m4':
        nextmap = 'e2m5'
    elif qc.mapname == 'e2m5':
        nextmap = 'e2m6'
    elif qc.mapname == 'e2m6':
        nextmap = 'e2m7'
    elif qc.mapname == 'e2m7':
        nextmap = 'ctfstart'
    #  episode three
    elif qc.mapname == 'e3m1':
        nextmap = 'e3m2'
    elif qc.mapname == 'e3m2':
        nextmap = 'e3m3'
    elif qc.mapname == 'e3m3':
        nextmap = 'e3m4'
    elif qc.mapname == 'e3m4':
        nextmap = 'e3m5'
    elif qc.mapname == 'e3m5':
        nextmap = 'e3m6'
    elif qc.mapname == 'e3m6':
        nextmap = 'e3m7'
    elif qc.mapname == 'e3m7':
        nextmap = 'ctfstart'
    #  episode four
    elif qc.mapname == 'e4m1':
        nextmap = 'e4m2'
    elif qc.mapname == 'e4m2':
        nextmap = 'e4m3'
    elif qc.mapname == 'e4m3':
        nextmap = 'e4m4'
    elif qc.mapname == 'e4m4':
        nextmap = 'e4m5'
    elif qc.mapname == 'e4m5':
        nextmap = 'e4m6'
    elif qc.mapname == 'e4m6':
        nextmap = 'e4m7'
    elif qc.mapname == 'e4m7':
        nextmap = 'e4m8'
    elif qc.mapname == 'e4m8':
        nextmap = 'ctfstart'
    #  the deathmatch arenas
    elif qc.mapname == 'dm1':
        nextmap = 'dm2'
    elif qc.mapname == 'dm2':
        nextmap = 'dm3'
    elif qc.mapname == 'dm3':
        nextmap = 'dm4'
    elif qc.mapname == 'dm4':
        nextmap = 'dm5'
    elif qc.mapname == 'dm5':
        nextmap = 'dm6'
    elif qc.mapname == 'dm6':
        nextmap = 'ctfstart'
    #  ctf episode one
    elif qc.mapname == 'ctf1':
        nextmap = 'ctf2'
    elif qc.mapname == 'ctf2':
        nextmap = 'ctf3'
    elif qc.mapname == 'ctf3':
        nextmap = 'ctf4'
    elif qc.mapname == 'ctf4':
        nextmap = 'ctf5'
    elif qc.mapname == 'ctf5':
        nextmap = 'ctf6'
    elif qc.mapname == 'ctf6':
        nextmap = 'ctf7'
    elif qc.mapname == 'ctf7':
        nextmap = 'ctf8'
    elif qc.mapname == 'ctf8':
        nextmap = 'ctfstart'
    #  ctf episode two
    elif qc.mapname == 'ctf2m1':
        nextmap = 'ctf2m2'
    elif qc.mapname == 'ctf2m2':
        nextmap = 'ctf2m3'
    elif qc.mapname == 'ctf2m3':
        nextmap = 'ctf2m5'
    elif qc.mapname == 'ctf2m4':
        nextmap = 'ctf2m5'
    elif qc.mapname == 'ctf2m5':
        nextmap = 'ctf2m7'
    elif qc.mapname == 'ctf2m6':
        nextmap = 'ctf2m7'
    elif qc.mapname == 'ctf2m7':
        nextmap = 'ctf2m8'
    elif qc.mapname == 'ctf2m8':
        nextmap = 'ctfstart'
    o = qc.spawn()
    o.map = nextmap
    o.think = execute_changelevel
    o.nextthink = qc.time + 0.1
    return 
    
    #  DISABLED from here
    #  find a trigger changelevel
    o = qc.find(qc.world, 'classname', 'trigger_changelevel')
    #  go back to start if no trigger_changelevel
    if not o:
        qc.mapname = 'start'
        o = qc.spawn()
        o.map = qc.mapname
        
    nextmap = o.map
    defs.gameover = defs.TRUE
    if o.nextthink < qc.time:
        o.think = execute_changelevel
        o.nextthink = qc.time + 0.1
        
    
# 
# ============
# CheckRules
# 
# Exit deathmatch games upon conditions
# ============
# 
def CheckRules(*qwp_extra):
    global pregameover
    global nextmap

    if defs.gameover or pregameover: #  someone else quit the game already
        return 
    if defs.gamestart:
        if (ctfgame.vote_leader != qc.world) and ctfgame.voteexit_time and (qc.time > ctfgame.voteexit_time):
            pregameover = 1
            o = qc.spawn()
            nextmap = ctfgame.vote_leader.map
            o.map = nextmap
            o.think = execute_changelevel
            o.nextthink = qc.time + 0.1
        return 
        
    timelimit = engine.cvar('timelimit') * 60
    fraglimit = engine.cvar('fraglimit')
    if (timelimit and qc.time >= timelimit) or (fraglimit and (qc.self.frags >= fraglimit)):
        pregameover = 1
        status.TeamEndScore()
        NextLevel()
        
    
# ============================================================================

def PlayerDeathThink(*qwp_extra):
    if (qc.self.flags & defs.FL_ONGROUND):
        forward = qc.self.velocity.length()
        forward -= 20
        if forward <= 0:
            qc.self.velocity = Vector(0, 0, 0)
        else:
            qc.self.velocity = forward * qc.self.velocity.normalize()
        
    #  wait for all buttons released
    if qc.self.deadflag == defs.DEAD_DEAD:
        if qc.self.button2 or qc.self.button1 or qc.self.button0:
            return 
        qc.self.deadflag = defs.DEAD_RESPAWNABLE
        return 
        
    #  wait for any button down
    if not qc.self.button2 and not qc.self.button1 and not qc.self.button0:
        return 
    qc.self.button0 = 0
    qc.self.button1 = 0
    qc.self.button2 = 0
    respawn()
    

def PlayerJump(*qwp_extra):
    if qc.self.flags & defs.FL_WATERJUMP:
        return 
    if qc.self.waterlevel >= 2:
        #  play swiming sound
        if qc.self.swim_flag < qc.time:
            qc.self.swim_flag = qc.time + 1
            if random.random() < 0.5:
                qc.self.sound(defs.CHAN_BODY, 'misc/water1.wav', 1, defs.ATTN_NORM)
            else:
                qc.self.sound(defs.CHAN_BODY, 'misc/water2.wav', 1, defs.ATTN_NORM)            
        return         
    if not (qc.self.flags & defs.FL_ONGROUND):
        return 
    if not (qc.self.flags & defs.FL_JUMPRELEASED):
        return  #  don't pogo stick
    qc.self.flags -= qc.self.flags & defs.FL_JUMPRELEASED
    qc.self.button2 = 0
    #  player jumping sound
    qc.self.sound(defs.CHAN_BODY, 'player/plyrjmp8.wav', 1, defs.ATTN_NORM)

    
# 
# ===========
# WaterMove
# 
# ============
# 
def WaterMove(*qwp_extra):
    # dprint (ftos(self.waterlevel));
    if qc.self.movetype == defs.MOVETYPE_NOCLIP:
        return 
    if qc.self.health < 0:
        return 
        
    if qc.self.waterlevel != 3:
        if qc.self.air_finished < qc.time:
            qc.self.sound(defs.CHAN_VOICE, 'player/gasp2.wav', 1, defs.ATTN_NORM)
        elif qc.self.air_finished < qc.time + 9:
            qc.self.sound(defs.CHAN_VOICE, 'player/gasp1.wav', 1, defs.ATTN_NORM)
        qc.self.air_finished = qc.time + 12
        qc.self.dmg = 2        
    elif qc.self.air_finished < qc.time:
        #  drown!
        if qc.self.pain_finished < qc.time:
            qc.self.dmg += 2
            if qc.self.dmg > 15:
                qc.self.dmg = 10
            combat.T_Damage(qc.self, qc.world, qc.world, qc.self.dmg)
            qc.self.pain_finished = qc.time + 1
                    
    if not qc.self.waterlevel:
        if qc.self.flags & defs.FL_INWATER:
            #  play leave water sound
            qc.self.sound(defs.CHAN_BODY, 'misc/outwater.wav', 1, defs.ATTN_NORM)
            qc.self.flags -= defs.FL_INWATER            
        return 
        
    if qc.self.watertype == defs.CONTENT_LAVA:
        #  do damage
        if qc.self.dmgtime < qc.time:
            if qc.self.radsuit_finished > qc.time:
                qc.self.dmgtime = qc.time + 1
            else:
                qc.self.dmgtime = qc.time + 0.2
            combat.T_Damage(qc.self, qc.world, qc.world, 10 * qc.self.waterlevel)                    
    elif qc.self.watertype == defs.CONTENT_SLIME:
        #  do damage
        if qc.self.dmgtime < qc.time and qc.self.radsuit_finished < qc.time:
            qc.self.dmgtime = qc.time + 1
            combat.T_Damage(qc.self, qc.world, qc.world, 4 * qc.self.waterlevel)
                    
    if not (qc.self.flags & defs.FL_INWATER):
        #  player enter water sound
        if qc.self.watertype == defs.CONTENT_LAVA:
            qc.self.sound(defs.CHAN_BODY, 'player/inlava.wav', 1, defs.ATTN_NORM)
        if qc.self.watertype == defs.CONTENT_WATER:
            qc.self.sound(defs.CHAN_BODY, 'player/inh2o.wav', 1, defs.ATTN_NORM)
        if qc.self.watertype == defs.CONTENT_SLIME:
            qc.self.sound(defs.CHAN_BODY, 'player/slimbrn2.wav', 1, defs.ATTN_NORM)
        qc.self.flags += defs.FL_INWATER
        qc.self.dmgtime = 0
        
    
def CheckWaterJump(*qwp_extra):
    #  check for a jump-out-of-water
    qc.makevectors(qc.self.angles)
    start = qc.self.origin
    start %= Vector(None, None, start.z + 8)
    qc.v_forward %= Vector(None, None, 0)
    qc.v_forward.normalize()
    end = start + qc.v_forward * 24
    qc.traceline(start, end, defs.TRUE, qc.self)
    if qc.trace_fraction < 1:
        #  solid at waist
        start %= Vector(None, None, start.z + qc.self.maxs.z - 8)
        end = start + qc.v_forward * 24
        qc.self.movedir = qc.trace_plane_normal * -50
        qc.traceline(start, end, defs.TRUE, qc.self)
        if qc.trace_fraction == 1:
            #  open at eye level
            qc.self.flags |= defs.FL_WATERJUMP
            qc.self.velocity %= Vector(None, None, 225)
            qc.self.flags -= qc.self.flags & defs.FL_JUMPRELEASED
            qc.self.teleport_time = qc.time + 2 #  safety net
            return 

            
# 
# ================
# PlayerPreThink
# 
# Called every frame before physics are run
# ================
# 
def PlayerPreThink(*qwp_extra):
    if intermission_running > 0:
        IntermissionThink() #  otherwise a button could be missed between
        return              #  the think tics
        
    status.TeamCapturePlayerUpdate()
    if qc.self.view_ofs == Vector(0, 0, 0):
        return  #  intermission or finale
    qc.makevectors(qc.self.v_angle) #  is this still used
    CheckRules()
    WaterMove()
    
    #  *TEAMPLAY*
    #  TeamCheckLock performs all necessary teamlock checking, and performs all
    #  actions needed.
    teamplay.TeamCheckLock()
    
    # 
    # 	if (self.waterlevel == 2)
    # 		CheckWaterJump ();
    # 
    if qc.self.deadflag >= defs.DEAD_DEAD:
        PlayerDeathThink()
        return 
        
    if qc.self.deadflag == defs.DEAD_DYING:
        return  #  dying, so do nothing
    if qc.self.button2:
        PlayerJump()        
    else:
        qc.self.flags |= defs.FL_JUMPRELEASED
    #  teleporters can force a non-moving pause time	
    if qc.time < qc.self.pausetime:
        qc.self.velocity = Vector(0, 0, 0)
    #  RUNE: If player has rune of elder magic (4), regeneration
    if qc.self.player_flag & defs.ITEM_RUNE4_FLAG:
        if qc.self.regen_time < qc.time:
            qc.self.regen_time = qc.time
            if qc.self.health < 150:
                qc.self.health += 5
                if qc.self.health > 150:
                    qc.self.health = 150
                qc.self.regen_time += 0.5
                weapons.RegenerationSound()
                
            if qc.self.armorvalue < 150 and qc.self.armortype:
                qc.self.armorvalue += 5
                if qc.self.armorvalue > 150:
                    qc.self.armorvalue = 150
                qc.self.regen_time += 0.5
                weapons.RegenerationSound()                                    
    #  RUNE
    if qc.time > qc.self.attack_finished and qc.self.currentammo == 0 and qc.self.weapon != defs.IT_AXE and qc.self.weapon != defs.IT_GRAPPLE:
        qc.self.weapon = weapons.W_BestWeapon()
        weapons.W_SetCurrentAmmo()
        
    #  Do grapple stuff if I'm on a hook
    if qc.self.on_hook:
        grapple.Service_Grapple()
    
    
# 
# ================
# CheckPowerups
# 
# Check for turning off powerups
# ================
# 
def CheckPowerups(*qwp_extra):
    if qc.self.health <= 0:
        return 
    #  invisibility
    if qc.self.invisible_finished:
        #  sound and screen flash when items starts to run out
        if qc.self.invisible_sound < qc.time:
            qc.self.sound(defs.CHAN_AUTO, 'items/inv3.wav', 0.5, defs.ATTN_IDLE)
            qc.self.invisible_sound = qc.time + ((random.random() * 3) + 1)
            
        if qc.self.invisible_finished < qc.time + 3:
            if qc.self.invisible_time == 1:
                qc.self.sprint(defs.PRINT_HIGH, 'Ring of Shadows magic is fading\012')
                qc.self.stuffcmd('bf\012')
                qc.self.sound(defs.CHAN_AUTO, 'items/inv2.wav', 1, defs.ATTN_NORM)
                qc.self.invisible_time = qc.time + 1
                
            if qc.self.invisible_time < qc.time:
                qc.self.invisible_time = qc.time + 1
                qc.self.stuffcmd('bf\012')
                          
        if qc.self.invisible_finished < qc.time:
            #  just stopped
            qc.self.items -= defs.IT_INVISIBILITY
            qc.self.invisible_finished = 0
            qc.self.invisible_time = 0
            
        #  use the eyes
        qc.self.frame = 0
        qc.self.modelindex = modelindex_eyes        
    else:
        qc.self.modelindex = modelindex_player #  don't use eyes
        
    #  invincibility
    if qc.self.invincible_finished:
        #  sound and screen flash when items starts to run out
        if qc.self.invincible_finished < qc.time + 3:
            if qc.self.invincible_time == 1:
                qc.self.sprint(defs.PRINT_HIGH, 'Protection is almost burned out\012')
                qc.self.stuffcmd('bf\012')
                qc.self.sound(defs.CHAN_AUTO, 'items/protect2.wav', 1, defs.ATTN_NORM)
                qc.self.invincible_time = qc.time + 1                
            if qc.self.invincible_time < qc.time:
                qc.self.invincible_time = qc.time + 1
                qc.self.stuffcmd('bf\012')
                            
        if qc.self.invincible_finished < qc.time:
            #  just stopped
            qc.self.items -= defs.IT_INVULNERABILITY
            qc.self.invincible_time = 0
            qc.self.invincible_finished = 0
            
        #  ZOID, next line isn't needed, EF_DIMLIGHT is handled by
        #  client.qc:CheckDimLight
        # 		if (self.invincible_finished > time)
        # 			self.effects = self.effects | EF_DIMLIGHT;
        # 		else
        # 			self.effects = self.effects - (self.effects & EF_DIMLIGHT);
        
    #  super damage
    if qc.self.super_damage_finished:
        #  sound and screen flash when items starts to run out
        if qc.self.super_damage_finished < qc.time + 3:
            if qc.self.super_time == 1:
                qc.self.sprint(defs.PRINT_HIGH, 'Quad Damage is wearing off\012')
                qc.self.stuffcmd('bf\012')
                qc.self.sound(defs.CHAN_AUTO, 'items/damage2.wav', 1, defs.ATTN_NORM)
                qc.self.super_time = qc.time + 1
                
            if qc.self.super_time < qc.time:
                qc.self.super_time = qc.time + 1
                qc.self.stuffcmd('bf\012')
                            
        if qc.self.super_damage_finished < qc.time:
            #  just stopped
            qc.self.items -= defs.IT_QUAD
            qc.self.super_damage_finished = 0
            qc.self.super_time = 0
            
        #  ZOID, next line isn't needed, EF_DIMLIGHT is handled by
        #  client.qc:CheckDimLight
        # 		if (self.super_damage_finished > time)
        # 			self.effects = self.effects | EF_DIMLIGHT;
        # 		else
        # 			self.effects = self.effects - (self.effects & EF_DIMLIGHT);
        
    #  suit	
    if qc.self.radsuit_finished:
        qc.self.air_finished = qc.time + 12 #  don't drown
        #  sound and screen flash when items starts to run out
        if qc.self.radsuit_finished < qc.time + 3:
            if qc.self.rad_time == 1:
                qc.self.sprint(defs.PRINT_HIGH, 'Air supply in Biosuit expiring\012')
                qc.self.stuffcmd('bf\012')
                qc.self.sound(defs.CHAN_AUTO, 'items/suit2.wav', 1, defs.ATTN_NORM)
                qc.self.rad_time = qc.time + 1
                
            if qc.self.rad_time < qc.time:
                qc.self.rad_time = qc.time + 1
                qc.self.stuffcmd('bf\012')
                            
        if qc.self.radsuit_finished < qc.time:
            #  just stopped
            qc.self.items -= defs.IT_SUIT
            qc.self.rad_time = 0
            qc.self.radsuit_finished = 0
                    
    #  Check to see about DIMLIGHT effects
    CheckDimLight()
    
    
# 
# ================
# PlayerPostThink
# 
# Called every frame after physics are run
# ================
# 
def PlayerPostThink(*qwp_extra):
    # dprint ("post think\n");
    if qc.self.view_ofs == Vector(0, 0, 0):
        return  #  intermission or finale
    if qc.self.deadflag:
        return 
    #  check to see if player landed and play landing sound	
    if (qc.self.jump_flag < -300) and (qc.self.flags & defs.FL_ONGROUND):
        if qc.self.watertype == defs.CONTENT_WATER:
            qc.self.sound(defs.CHAN_BODY, 'player/h2ojump.wav', 1, defs.ATTN_NORM)
        elif qc.self.jump_flag < -650:
            combat.T_Damage(qc.self, qc.world, qc.world, 5)
            qc.self.sound(defs.CHAN_VOICE, 'player/land2.wav', 1, defs.ATTN_NORM)
            qc.self.deathtype = 'falling'            
        else:
            qc.self.sound(defs.CHAN_VOICE, 'player/land.wav', 1, defs.ATTN_NORM)
        
    qc.self.jump_flag = qc.self.velocity.z
    CheckPowerups()
    weapons.W_WeaponFrame()

    
# 
# ===========
# ClientConnect
# 
# called when a player connects to a server
# ============
# 
def ClientConnect(*qwp_extra):
    engine.bprint(defs.PRINT_HIGH, qc.self.netname)
    engine.bprint(defs.PRINT_HIGH, ' entered the game\012')
    qc.self.motd_count = 1
    qc.self.player_flag -= qc.self.player_flag & defs.PF_GHOST
    qc.self.suicide_count = 0
    qc.self.killed = 0
    qc.self.player_flag = 0
    #  *TEAMPLAY*
    #  If this is our first connection, parm10 is < 0
    #  Set lastteam negative.
    if qc.parm10 < 0 or qc.self.steam < 0:
        qc.self.steam = -1
        teamplay.TeamAssign()
        if defs.teamplay & teamplay.TEAM_LOCK_COLORS: #  force a stuff cmd in think
            qc.self.player_flag |= defs.TEAM_STUFF_COLOR
        
    #  a client connecting during an intermission can cause problems
    if intermission_running:
        GotoNextMap()

    
# 
# ===========
# ClientDisconnect
# 
# called when a player disconnects from a server
# ============
# 
def ClientDisconnect(*qwp_extra):
    #  let everyone else know
    engine.bprint(defs.PRINT_HIGH, qc.self.netname)
    engine.bprint(defs.PRINT_HIGH, ' left the game with ')
    engine.bprint(defs.PRINT_HIGH, str(qc.self.frags))
    engine.bprint(defs.PRINT_HIGH, ' frags\012')
    qc.self.sound(defs.CHAN_BODY, 'player/tornoff2.wav', 1, defs.ATTN_NONE)
    items.DropRune()
    teamplay.TeamCaptureDropFlagOfPlayer(qc.self)
    player.set_suicide_frame()
    qc.self.player_flag |= defs.PF_GHOST
    qc.self.steam = -1
    qc.self.frags = 0
    qc.self.statstate = 0
    
# 
# ===========
# ClientObituary
# 
# called when a player dies
# ============
# 
def ClientObituary(targ, attacker, *qwp_extra):
    #  *XXX* EXPERT CTF variable for 
    #  flag/flag carrier defense bonus determination
    head = engine.world
    flag_radius = 0
    flag_carrier_radius = 0
    temp = 0
    deathstring = None
    deathstring2 = None
    s = None
    
    rnum = random.random()
    if targ.classname == 'player':
        #  *XXX* EXPERT CTF: 
        #  When the flag carrier dies, reset the last_hurt_carrier field in
        #  all players on the opposite team from the flag carrier.  The carrier
        #  has been killed, so there is no longer a reason to award points for
        #  killing off his assailants
        if targ.player_flag & defs.ITEM_ENEMY_FLAG:
            head = qc.find(qc.world, 'classname', 'player')
            while head != qc.world:
                if head.steam != targ.steam:
                    head.last_hurt_carrier = -10
                head = qc.find(head, 'classname', 'player')
                            
        #  END EXPERT CTF
        if attacker.classname == 'teledeath':
            engine.bprint(defs.PRINT_MEDIUM, targ.netname)
            engine.bprint(defs.PRINT_MEDIUM, ' was telefragged by ')
            engine.bprint(defs.PRINT_MEDIUM, attacker.owner.netname)
            engine.bprint(defs.PRINT_MEDIUM, '\012')
            attacker.owner.frags += 1
            return 
            
        if attacker.classname == 'teledeath2':
            engine.bprint(defs.PRINT_MEDIUM, "Satan's power deflects ")
            engine.bprint(defs.PRINT_MEDIUM, targ.netname)
            engine.bprint(defs.PRINT_MEDIUM, "'s telefrag\012")
            targ.frags -= 1
            targ.logfrag(targ)
            return 
            
        if attacker.classname == 'player':
            if targ == attacker:
                #  killed self
                attacker.logfrag(attacker)
                attacker.frags -= 1
                engine.bprint(defs.PRINT_MEDIUM, targ.netname)
                if qc.self.killed == 99:
                    # ZOID: try if player was gibbed for changing teams
                    if defs.teamplay & teamplay.TEAM_STATIC_TEAMS:
                        engine.bprint(defs.PRINT_MEDIUM, ' tried to change teams\012')
                    else:
                        engine.bprint(defs.PRINT_MEDIUM, ' changed teams\012')                    
                elif targ.weapon == 64 and targ.waterlevel > 1:
                    engine.bprint(defs.PRINT_MEDIUM, ' discharges into the water.\012')
                    return                     
                elif targ.weapon == defs.IT_GRENADE_LAUNCHER:
                    engine.bprint(defs.PRINT_MEDIUM, ' tries to put the pin back in\012')                    
                elif rnum:
                    engine.bprint(defs.PRINT_MEDIUM, ' becomes bored with life\012')                    
                else:
                    engine.bprint(defs.PRINT_MEDIUM, ' checks if his weapon is loaded\012')                    
                return                 
            else:
                #  *TEAMPLAY*
                #  TeamFragPenalty returns true if the attacker gets a frag penalty for
                #  killing this target.  It also deducts frags as needed.
                if not teamplay.TeamFragPenalty(targ, attacker):
                    #  the attacker is award the normal one frag.. now we 
                    #  determine if he gets any bonuses
                    attacker.logfrag(targ)
                    attacker.frags += 1
                    if (targ.player_flag & defs.ITEM_ENEMY_FLAG) and (targ.steam != attacker.steam):
                        # ZOID: one team fragged the other team's flag carrier
                        #  *XXX* EXPERT CTF
                        #  Mark the attacker with the time at which he killed the flag
                        #  carrier, for awarding assist points
                        attacker.last_fragged_carrier = qc.time
                        #  *XXX* EXPERT CTF: give player only the normal amount of frags
                        #  if the carrier has only had the flag for a few seconds, to
                        #  prevent ppl intentionally allowing enemies to grab the flag,
                        #  then immediately fragging them
                        if targ.flag_since + teamplay.TEAM_CAPTURE_CARRIER_FLAG_SINCE_TIMEOUT > qc.time:
                            attacker.sprint(defs.PRINT_MEDIUM, 'Enemy flag carrier killed, no bonus\012')
                            
                        else:
                            attacker.frags += teamplay.TEAM_CAPTURE_FRAG_CARRIER_BONUS
                            attacker.sprint(defs.PRINT_MEDIUM, 'Enemy flag carrier killed: ')
                            s = str(teamplay.TEAM_CAPTURE_FRAG_CARRIER_BONUS)
                            attacker.sprint(defs.PRINT_MEDIUM, s)
                            attacker.sprint(defs.PRINT_MEDIUM, ' bonus frags\012')
                            
                        #  END FLAG CARRIER FRAG CODE
                        
                    #  *XXX* EXPERT CTF
                    #  This code checks for all game-critical kills OTHER THAN fragging the enemy
                    #  flag carrier, like killing players who are trying to kill your flag carrier
                    #  or trying to grab your flag, and hands out bonus frags.
                    #  The two variables below track whether special bonus frags have already
                    #  been awarded for the attacker or target being near the flag or flag carrier.  
                    flag_radius = 0
                    flag_carrier_radius = 0
                    #  get a string for the attacker's team now, for later announcements
                    s = teamplay.GetCTFTeam(attacker.steam)
                    if (targ.last_hurt_carrier + teamplay.TEAM_CAPTURE_CARRIER_DANGER_PROTECT_TIMEOUT > qc.time) and not (attacker.player_flag & defs.ITEM_ENEMY_FLAG):
                        #  a player on the same team as the flag carrier killed 
                        #  someone who recently shot the flag carrier
                        attacker.frags += teamplay.TEAM_CAPTURE_CARRIER_DANGER_PROTECT_BONUS
                        flag_carrier_radius = 1
                        #  NOTE: getting CARRIER_DANGER_PROTECT_BONUS precludes getting
                        #  other kinds of bonuses for defending the flag carrier, since
                        #  it's worth more points
                        engine.bprint(defs.PRINT_MEDIUM, attacker.netname)
                        engine.bprint(defs.PRINT_MEDIUM, ' defends ')
                        engine.bprint(defs.PRINT_MEDIUM, s)
                        engine.bprint(defs.PRINT_MEDIUM, "'s flag carrier against an agressive enemy\012")
                        
                    #  *XXX* EXPERT CTF
                    #  Bonusus for defending the flag carrier or the flag itself.
                    #  Extra frags are awarded if either the attacker or the target are
                    #  1. within 40 feet of a flag carrier on the same team as the attacker
                    #  2. within 40 feet of the attacker's flag
                    #  These bonuses are cumulative with respect to defending both the
                    #  flag and the flag carrier at the same time, but not cumulative with
                    #  respect to both the target and attacker being near the object being defended
                    #  find flags or flag carriers within a radius of the attacker
                    for head in engine.findradius(attacker.origin, teamplay.TEAM_CAPTURE_ATTACKER_PROTECT_RADIUS):
                        if head.classname == 'player':
                            if (head.steam == attacker.steam) and (head.player_flag & defs.ITEM_ENEMY_FLAG) and (head != attacker) and (not flag_carrier_radius):
                                #  attacker was near his own flag carrier
                                attacker.frags += teamplay.TEAM_CAPTURE_CARRIER_PROTECT_BONUS
                                flag_carrier_radius = 1
                                engine.bprint(defs.PRINT_MEDIUM, attacker.netname)
                                engine.bprint(defs.PRINT_MEDIUM, ' defends ')
                                engine.bprint(defs.PRINT_MEDIUM, s)
                                engine.bprint(defs.PRINT_MEDIUM, "'s flag carrier\012")
                                                            
                        if (head.classname == 'item_flag_team1') or (head.classname == 'item_flag_team2'):
                            if ((attacker.steam == teamplay.TEAM_COLOR1) and (head.classname == 'item_flag_team1')) or ((attacker.steam == teamplay.TEAM_COLOR2) and (head.classname == 'item_flag_team2')):
                                #  attacker was near his own flag
                                attacker.frags += teamplay.TEAM_CAPTURE_FLAG_DEFENSE_BONUS
                                flag_radius = 1
                                engine.bprint(defs.PRINT_MEDIUM, attacker.netname)
                                engine.bprint(defs.PRINT_MEDIUM, ' defends the ')
                                engine.bprint(defs.PRINT_MEDIUM, s)
                                engine.bprint(defs.PRINT_MEDIUM, ' flag\012')
                                                                                    
                    #  find flags or flag carriers within a radius from the target
                    for head in engine.findradius(targ.origin, teamplay.TEAM_CAPTURE_TARGET_PROTECT_RADIUS):
                        if head.classname == 'player':
                            if (head.steam == attacker.steam) and (head.player_flag & defs.ITEM_ENEMY_FLAG) and (head != attacker) and (not flag_carrier_radius):
                                #  prevents redundant points awarded
                                #  target was near attacker's flag carrier
                                attacker.frags += teamplay.TEAM_CAPTURE_CARRIER_PROTECT_BONUS
                                flag_carrier_radius = 1
                                engine.bprint(defs.PRINT_MEDIUM, attacker.netname)
                                engine.bprint(defs.PRINT_MEDIUM, ' defends ')
                                engine.bprint(defs.PRINT_MEDIUM, s)
                                engine.bprint(defs.PRINT_MEDIUM, "'s flag carrier\012")                                
                            
                        if ((attacker.steam == teamplay.TEAM_COLOR1) and (head.classname == 'item_flag_team1')) or ((attacker.steam == teamplay.TEAM_COLOR2) and (head.classname == 'item_flag_team2')) and (not flag_radius):
                            #  prevents redundant points awarded
                            #  target was near attacker's flag
                            attacker.frags += teamplay.TEAM_CAPTURE_FLAG_DEFENSE_BONUS
                            flag_radius = 1
                            engine.bprint(defs.PRINT_MEDIUM, attacker.netname)
                            engine.bprint(defs.PRINT_MEDIUM, ' defends the ')
                            engine.bprint(defs.PRINT_MEDIUM, s)
                            engine.bprint(defs.PRINT_MEDIUM, ' flag\012')
                                                                        
                #  *XXX* EXPERT CTF 
                #  End frag determination code.  Now determine death text for
                #  a member of one team killing a member of the other
                #  *TEAMPLAY*
                #  TeamDeathPenalty kills the attacker if necessary and adjusts frags to
                #  offset the one frag penalty for dying.
                teamplay.TeamDeathPenalty(targ, attacker)
                rnum = attacker.weapon
                if rnum == defs.IT_AXE:
                    deathstring = ' was ax-murdered by '
                    deathstring2 = '\012'
                    
                if rnum == defs.IT_GRAPPLE:
                    temp = random.random()
                    if temp < 0.5:
                        deathstring = ' was hooked by '
                        deathstring2 = '\012'                        
                    elif temp > 0.5:
                        deathstring = ' was disemboweled by '
                        deathstring2 = '\012'
                                            
                if rnum == defs.IT_SHOTGUN:
                    deathstring = ' chewed on '
                    deathstring2 = "'s boomstick\012"
                    
                if rnum == defs.IT_SUPER_SHOTGUN:
                    deathstring = ' ate 2 loads of '
                    deathstring2 = "'s buckshot\012"
                    
                if rnum == defs.IT_NAILGUN:
                    deathstring = ' was nailed by '
                    deathstring2 = '\012'
                    
                if rnum == defs.IT_SUPER_NAILGUN:
                    deathstring = ' was punctured by '
                    deathstring2 = '\012'
                    
                if rnum == defs.IT_GRENADE_LAUNCHER:
                    deathstring = ' eats '
                    deathstring2 = "'s pineapple\012"
                    if targ.health < -40:
                        deathstring = ' was gibbed by '
                        deathstring2 = "'s grenade\012"
                                            
                if rnum == defs.IT_ROCKET_LAUNCHER:
                    if attacker.items & defs.IT_QUAD:
                        deathstring = ' was destroyed by '
                        deathstring2 = "'s Quad rocket\012"                        
                    else:
                        deathstring = ' rides '
                        deathstring2 = "'s rocket\012"
                        if targ.health < -40:
                            deathstring = ' was gibbed by '
                            deathstring2 = "'s rocket\012"                                                    
                    
                if rnum == defs.IT_LIGHTNING:
                    deathstring = ' accepts '
                    if attacker.waterlevel > 1:
                        deathstring2 = "'s discharge\012"
                    else:
                        deathstring2 = "'s shaft\012"
                    
                engine.bprint(defs.PRINT_MEDIUM, targ.netname)
                engine.bprint(defs.PRINT_MEDIUM, deathstring)
                engine.bprint(defs.PRINT_MEDIUM, attacker.netname)
                engine.bprint(defs.PRINT_MEDIUM, deathstring2)                
            return             
        else:
            targ.logfrag(targ)
            targ.frags -= 1 #  killed self
            rnum = targ.watertype
            engine.bprint(defs.PRINT_MEDIUM, targ.netname)
            if rnum == -3:
                if random.random() < 0.5:
                    engine.bprint(defs.PRINT_MEDIUM, ' sleeps with the fishes\012')
                else:
                    engine.bprint(defs.PRINT_MEDIUM, ' sucks it down\012')
                return 
                
            elif rnum == -4:
                if random.random() < 0.5:
                    engine.bprint(defs.PRINT_MEDIUM, ' gulped a load of slime\012')
                else:
                    engine.bprint(defs.PRINT_MEDIUM, " can't exist on slime alone\012")
                return 
                
            elif rnum == -5:
                if targ.health < -15:
                    engine.bprint(defs.PRINT_MEDIUM, ' burst into flames\012')
                    return                     
                if random.random() < 0.5:
                    engine.bprint(defs.PRINT_MEDIUM, ' turned into hot slag\012')
                else:
                    engine.bprint(defs.PRINT_MEDIUM, ' visits the Volcano God\012')
                return 
                
            if attacker.flags & defs.FL_MONSTER:
                if attacker.classname == 'monster_army':
                    engine.bprint(defs.PRINT_MEDIUM, ' was shot by a Grunt\012')
                if attacker.classname == 'monster_demon1':
                    engine.bprint(defs.PRINT_MEDIUM, ' was eviscerated by a Fiend\012')
                if attacker.classname == 'monster_dog':
                    engine.bprint(defs.PRINT_MEDIUM, ' was mauled by a Rottweiler\012')
                if attacker.classname == 'monster_dragon':
                    engine.bprint(defs.PRINT_MEDIUM, ' was fried by a Dragon\012')
                if attacker.classname == 'monster_enforcer':
                    engine.bprint(defs.PRINT_MEDIUM, ' was blasted by an Enforcer\012')
                if attacker.classname == 'monster_fish':
                    engine.bprint(defs.PRINT_MEDIUM, ' was fed to the Rotfish\012')
                if attacker.classname == 'monster_hell_knight':
                    engine.bprint(defs.PRINT_MEDIUM, ' was slain by a Death Knight\012')
                if attacker.classname == 'monster_knight':
                    engine.bprint(defs.PRINT_MEDIUM, ' was slashed by a Knight\012')
                if attacker.classname == 'monster_ogre':
                    engine.bprint(defs.PRINT_MEDIUM, ' was destroyed by an Ogre\012')
                if attacker.classname == 'monster_oldone':
                    engine.bprint(defs.PRINT_MEDIUM, ' became one with Shub-Niggurath\012')
                if attacker.classname == 'monster_shalrath':
                    engine.bprint(defs.PRINT_MEDIUM, ' was exploded by a Vore\012')
                if attacker.classname == 'monster_tarbaby':
                    engine.bprint(defs.PRINT_MEDIUM, ' was slimed by a Spawn\012')
                if attacker.classname == 'monster_vomit':
                    engine.bprint(defs.PRINT_MEDIUM, ' was vomited on by a Vomitus\012')
                if attacker.classname == 'monster_wizard':
                    engine.bprint(defs.PRINT_MEDIUM, ' was scragged by a Scrag\012')
                if attacker.classname == 'monster_zombie':
                    engine.bprint(defs.PRINT_MEDIUM, ' joins the Zombies\012')
                return 
                
            if attacker.classname == 'explo_box':
                engine.bprint(defs.PRINT_MEDIUM, ' blew up\012')
                return 
                
            if attacker.solid == defs.SOLID_BSP and attacker != qc.world:
                engine.bprint(defs.PRINT_MEDIUM, ' was squished\012')
                return 
                
            if targ.deathtype == 'falling':
                targ.deathtype = None
                engine.bprint(defs.PRINT_MEDIUM, ' fell to his death\012')
                return 
                
            if attacker.classname == 'trap_shooter' or attacker.classname == 'trap_spikeshooter':
                engine.bprint(defs.PRINT_MEDIUM, ' was spiked\012')
                return 
                
            if attacker.classname == 'fireball':
                engine.bprint(defs.PRINT_MEDIUM, ' ate a lavaball\012')
                return 
                
            if attacker.classname == 'trigger_changelevel':
                engine.bprint(defs.PRINT_MEDIUM, ' tried to leave\012')
                return 
                
            engine.bprint(defs.PRINT_MEDIUM, ' died\012')
            
                        
def qwp_reset_client(*qwp_extra):
    global modelindex_eyes
    global modelindex_player
    global pregameover
    global nextmap
    global intermission_running
    global intermission_exittime
    
    modelindex_eyes = 0
    modelindex_player = 0
    pregameover = 0
    nextmap = None
    intermission_running = 0
    intermission_exittime = 0
