###
### Generated by QuakeC -> Python translator
### Id: qc2python.py,v 1.5 2001/02/05 21:15:44 barryp Exp 
###
### 2001-02-17 Cleaned up translation (barryp)
###
from qwpython.qwsv import engine, Vector
from qwpython.qcsupport import qc

import defs
import teamplay
import status

#  Spectator functions
#  Added Aug11'97 by Zoid <zoid@idsoftware.com>
# 
#  These functions are called from the server if they exist.
#  Note that Spectators only have one think since they movement code doesn't
#  track them much.  Impulse commands work as usual, but don't call
#  the regular ImpulseCommand handler in weapons.qc since Spectators don't
#  have any weapons and things can explode.
# 
#    --- Zoid.
# 
# ===========
# SpectatorConnect
# 
# called when a spectator connects to a server
# ============
# 
def SpectatorConnect(*qwp_extra):
    engine.bprint(defs.PRINT_MEDIUM, 'Spectator ')
    engine.bprint(defs.PRINT_MEDIUM, qc.self.netname)
    engine.bprint(defs.PRINT_MEDIUM, ' entered the game\012')
    qc.self.goalentity = qc.world #  used for impulse 1 below
    qc.self.motd_count = 1
    qc.self.classname = 'spectator'

    
# 
# ===========
# SpectatorDisconnect
# 
# called when a spectator disconnects from a server
# ============
# 
def SpectatorDisconnect(*qwp_extra):
    engine.bprint(defs.PRINT_MEDIUM, 'Spectator ')
    engine.bprint(defs.PRINT_MEDIUM, qc.self.netname)
    engine.bprint(defs.PRINT_MEDIUM, ' left the game\012')
    qc.self.statstate = 0

    
# 
# ================
# SpectatorImpulseCommand
# 
# Called by SpectatorThink if the spectator entered an impulse
# ================
# 
def SpectatorImpulseCommand(*qwp_extra):
    if qc.self.impulse == 1:
        #  teleport the spectator to the next spawn point
        #  note that if the spectator is tracking, this doesn't do
        #  much
        qc.self.goalentity = qc.find(qc.self.goalentity, 'classname', 'info_player_deathmatch')
        if qc.self.goalentity == qc.world:
            qc.self.goalentity = qc.find(qc.self.goalentity, 'classname', 'info_player_deathmatch')
        if qc.self.goalentity != qc.world:
            qc.setorigin(qc.self, qc.self.goalentity.origin)
            qc.self.angles = qc.self.goalentity.angles
            qc.self.fixangle = defs.TRUE #  turn this way immediately                    
    elif qc.self.impulse == 23:
        teamplay.TeamFlagStatusReport()
    elif qc.self.impulse == 25:
        teamplay.TeamPrintSettings()
    elif qc.self.impulse == 70:
        if qc.self.statstate < 0:
            qc.self.statstate = 0
            qc.self.sprint(defs.PRINT_HIGH, 'Status bar on (impulse 71 to 81 to set size)\012')            
        else:
            qc.self.statstate = -1
            qc.self.sprint(defs.PRINT_HIGH, 'Status bar off.\012')                    
    elif qc.self.impulse >= 71 and qc.self.impulse <= 81:
        qc.self.statstate = qc.self.impulse - 71
        qc.self.sprint(defs.PRINT_HIGH, 'Status bar set\012')
        
    qc.self.impulse = 0
    
    
# 
# ================
# SpectatorThink
# 
# Called every frame after physics are run
# ================
# 
def SpectatorThink(*qwp_extra):
    #  self.origin, etc contains spectator position, so you could
    #  do some neat stuff here
    status.TeamCapturePlayerUpdate()
    if qc.self.impulse:
        SpectatorImpulseCommand()
