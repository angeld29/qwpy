###
### Generated by QuakeC -> Python translator
### Id: qc2python.py,v 1.5 2001/02/05 21:15:44 barryp Exp 
###
### 2001-02-17 Cleaned up translation (barryp)
###
from qwpython.qwsv import engine, Vector
from qwpython.qcsupport import qc

import defs

def SUB_Null(*qwp_extra):
    pass


def SUB_Remove(*qwp_extra):
    qc.self.remove()
    
# 
# QuakeEd only writes a single float for angles (bad idea), so up and down are
# just constant angles.
# 
def SetMovedir(*qwp_extra):
    if qc.self.angles == Vector(0, -1, 0):
        qc.self.movedir = Vector(0, 0, 1)
    elif qc.self.angles == Vector(0, -2, 0):
        qc.self.movedir = Vector(0, 0, -1)
    else:
        qc.makevectors(qc.self.angles)
        qc.self.movedir = qc.v_forward
        
    qc.self.angles = Vector(0, 0, 0)

    
# 
# ================
# InitTrigger
# ================
# 
def InitTrigger(*qwp_extra):
    #  trigger angles are used for one-way touches.  An angle of 0 is assumed
    #  to mean no restrictions, so use a yaw of 360 instead.
    if qc.self.angles != Vector(0, 0, 0):
        SetMovedir()
    qc.self.solid = defs.SOLID_TRIGGER
    qc.self.setmodel(qc.self.model) #  set size and link into world
    qc.self.movetype = defs.MOVETYPE_NONE
    qc.self.modelindex = 0
    qc.self.model = None

    
# 
# =============
# SUB_CalcMove
# 
# calculate self.velocity and self.nextthink to reach dest from
# self.origin traveling at speed
# ===============
# 
def SUB_CalcMoveEnt(ent, tdest, tspeed, func, *qwp_extra):
    stemp = qc.self
    qc.self = ent
    SUB_CalcMove(tdest, tspeed, func)
    qc.self = stemp
    

def SUB_CalcMove(tdest, tspeed, func, *qwp_extra):
    if not tspeed:
        qc.objerror('No speed is defined!')
    qc.self.think1 = func
    qc.self.finaldest = tdest
    qc.self.think = SUB_CalcMoveDone
    if tdest == qc.self.origin:
        qc.self.velocity = Vector(0, 0, 0)
        qc.self.nextthink = qc.self.ltime + 0.1
        return 
        
    #  set destdelta to the vector needed to move
    vdestdelta = tdest - qc.self.origin
    #  calculate length of vector
    len = vdestdelta.length()
    #  divide by speed to get time to reach dest
    traveltime = len / tspeed
    if traveltime < 0.1:
        qc.self.velocity = Vector(0, 0, 0)
        qc.self.nextthink = qc.self.ltime + 0.1
        return 
        
    #  set nextthink to trigger a think when dest is reached
    qc.self.nextthink = qc.self.ltime + traveltime
    #  scale the destdelta vector by the time spent traveling to get velocity
    qc.self.velocity = vdestdelta * (1 / traveltime) #  qcc won't take vec/float	

    
# 
# ============
# After moving, set origin to exact final destination
# ============
# 
def SUB_CalcMoveDone(*qwp_extra):
    qc.setorigin(qc.self, qc.self.finaldest)
    qc.self.velocity = Vector(0, 0, 0)
    qc.self.nextthink = -1
    if qc.self.think1:
        qc.self.think1()

    
# 
# =============
# SUB_CalcAngleMove
# 
# calculate self.avelocity and self.nextthink to reach destangle from
# self.angles rotating 
# 
# The calling function should make sure self.think is valid
# ===============
# 
def SUB_CalcAngleMoveEnt(ent, destangle, tspeed, func, *qwp_extra):
    stemp = qc.self
    qc.self = ent
    SUB_CalcAngleMove(destangle, tspeed, func)
    qc.self = stemp
    

def SUB_CalcAngleMove(destangle, tspeed, func, *qwp_extra):
    if not tspeed:
        qc.objerror('No speed is defined!')
    #  set destdelta to the vector needed to move
    destdelta = destangle - qc.self.angles
    #  calculate length of vector
    len = destdelta.length()
    #  divide by speed to get time to reach dest
    traveltime = len / tspeed
    #  set nextthink to trigger a think when dest is reached
    qc.self.nextthink = qc.self.ltime + traveltime
    #  scale the destdelta vector by the time spent traveling to get velocity
    qc.self.avelocity = destdelta * (1 / traveltime)
    qc.self.think1 = func
    qc.self.finalangle = destangle
    qc.self.think = SUB_CalcAngleMoveDone

    
# 
# ============
# After rotating, set angle to exact final angle
# ============
# 
def SUB_CalcAngleMoveDone(*qwp_extra):
    qc.self.angles = qc.self.finalangle
    qc.self.avelocity = Vector(0, 0, 0)
    qc.self.nextthink = -1
    if qc.self.think1:
        qc.self.think1()
    
# =============================================================================

def DelayThink(*qwp_extra):
    defs.activator = qc.self.enemy
    SUB_UseTargets()
    qc.self.remove()
    
# 
# ==============================
# SUB_UseTargets
# 
# the global "activator" should be set to the entity that initiated the firing.
# 
# If self.delay is set, a DelayedUse entity will be created that will actually
# do the SUB_UseTargets after that many seconds have passed.
# 
# Centerprints any self.message to the activator.
# 
# Removes all entities with a targetname that match self.killtarget,
# and removes them, so some events can remove other triggers.
# 
# Search for (string)targetname in all entities that
# match (string)self.target and call their .use function
# 
# ==============================
# 
def SUB_UseTargets(*qwp_extra):
    # 
    #  check for a delay
    # 
    if qc.self.delay:
        #  create a temp object to fire at a later time
        t = qc.spawn()
        t.classname = 'DelayedUse'
        t.nextthink = qc.time + qc.self.delay
        t.think = DelayThink
        t.enemy = defs.activator
        t.message = qc.self.message
        t.killtarget = qc.self.killtarget
        t.target = qc.self.target
        return 
        
    # 
    #  print the message
    # 
    if defs.activator.classname == 'player' and qc.self.message != None:
        qc.centerprint(defs.activator, qc.self.message)
        if not qc.self.noise:
            defs.activator.sound(defs.CHAN_VOICE, 'misc/talk.wav', 1, defs.ATTN_NORM)
        
    # 
    #  kill the killtagets
    # 
    if qc.self.killtarget:
        t = qc.world
        while 1:
            t = qc.find(t, 'targetname', qc.self.killtarget)
            if not t:
                return 
            t.remove()
                    
    # 
    #  fire targets
    # 
    if qc.self.target:
        act = defs.activator
        t = qc.world
        while 1:
            t = qc.find(t, 'targetname', qc.self.target)
            if not t:
                return 
                
            stemp = qc.self
            otemp = qc.other
            qc.self = t
            qc.other = stemp
            if qc.self.use != SUB_Null:
                if qc.self.use:
                    qc.self.use()
                
            qc.self = stemp
            qc.other = otemp
            defs.activator = act
