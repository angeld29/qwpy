###
### Generated by QuakeC -> Python translator
### Id: qc2python.py,v 1.5 2001/02/05 21:15:44 barryp Exp 
###
### 2001-02-17 Cleaned up translation (barryp)

from qwpython.qwsv import engine, Vector
from qwpython.qcsupport import qc

import triggers
import defs
import status
import subs
import random

VOTEEXIT_TIME_LIMIT = 60 #  60 seconds after first vote
voteexit_time = 0
vote_leader = engine.world #  current leader
lastvotespawn = engine.world

# QUAKED info_vote_destination (.5 .5 .5) (-8 -8 -8) (8 8 32)
# This is the destination marker for a voteexit.  It should have a "targetname" 
# field with the same value as a voteexit's "target" field.
# 
def info_vote_destination(*qwp_extra):
    #  this does nothing, just serves as a target spot
    qc.self.mangle = qc.self.angles
    qc.self.angles = Vector(0, 0, 0)
    qc.self.model = None
    qc.self.origin += Vector(0, 0, 27)
    if not qc.self.targetname:
        qc.objerror('no targetname')
    

def voteexit_teleport(*qwp_extra):
    global lastvotespawn
    
    #  put a tfog where the player was
    triggers.spawn_tfog(qc.other.origin)
    #  if we aren't in custom mode, just find a deathmatch target
    #  find the destination 
    if not qc.self.target:
        lastvotespawn = qc.find(lastvotespawn, 'classname', 'info_player_deathmatch')
        if lastvotespawn == qc.world:
            lastvotespawn = qc.find(lastvotespawn, 'classname', 'info_player_deathmatch')
        t = lastvotespawn        
    else:
        t = qc.find(qc.world, 'targetname', qc.self.target)
    if not t:
        qc.objerror("couldn't find target")
    #  spawn a tfog flash in front of the destination
    qc.makevectors(t.mangle)
    org = t.origin + 32 * qc.v_forward
    triggers.spawn_tfog(org)
    triggers.spawn_tdeath(t.origin, qc.other)
    #  move the player and lock him down for a little while
    if not qc.other.health:
        qc.other.origin = t.origin
        qc.other.velocity = (qc.v_forward * qc.other.velocity.x) + (qc.v_forward * qc.other.velocity.y)
        return 
        
    qc.setorigin(qc.other, t.origin)
    qc.other.angles = t.mangle
    qc.other.fixangle = 1 #  turn this way immediately
    qc.other.teleport_time = qc.time + 0.7
    if qc.other.flags & defs.FL_ONGROUND:
        qc.other.flags -= defs.FL_ONGROUND
    qc.other.velocity = qc.v_forward * 300
    

def voteexit_touch(*qwp_extra):
    global vote_leader
    global voteexit_time
    
    if qc.other.classname != 'player':
        return 
    #  only teleport living creatures
    if qc.other.health <= 0 or qc.other.solid != defs.SOLID_SLIDEBOX:
        return 
    if qc.other.voted:
        if qc.other.voted < qc.time:
            status.TeamPlayerUpdate(qc.other, 'You have already voted.')
        qc.other.voted = qc.time + 1
        voteexit_teleport()
        return 
        
    #  non-zero for vote, time is when to display a 'you voted' msg
    qc.other.voted = qc.time + 1
    subs.SUB_UseTargets()
    engine.bprint(defs.PRINT_HIGH, qc.other.netname)
    engine.bprint(defs.PRINT_HIGH, ' has voted for ')
    engine.bprint(defs.PRINT_HIGH, qc.self.message)
    engine.bprint(defs.PRINT_HIGH, '\012')
    #  ok, the player has voted for this exit
    qc.self.cnt += 1
    #  find new leader
    #  we're on the start map, something special is happening
    vote_leader = qc.world
    t = qc.find(qc.world, 'classname', 'trigger_voteexit')
    while t != qc.world:
        if (t.cnt > vote_leader.cnt) and (t != qc.self):
            vote_leader = t
        t = qc.find(t, 'classname', 'trigger_voteexit')
        
    #  if we are higher than the current leader, then we are the new
    #  leader, if we are same, half chance
    if qc.self.cnt > vote_leader.cnt:
        vote_leader = qc.self
    elif (qc.self.cnt == vote_leader.cnt) and (random.random() > 0.5):
        vote_leader = qc.self
    #  we check here about exit time
    if vote_leader != qc.world and voteexit_time == 0:
        voteexit_time = qc.time + VOTEEXIT_TIME_LIMIT
    #  notify everyone about the change
    status.TeamCaptureResetUpdate()
    voteexit_teleport()

    
# QUAKED trigger_voteexit (.5 .5 .5) ?
# A merge of trigger_changelevel and trigger_teleport.  A player touching
# this this teleported just like a trigger_teleport, except this triggers
# .cnt field gets incremented.  This allows players to vote for their exit.
# See status.qc for the display and total of the voting.
# Any object touching this will be transported to the corresponding 
# info_vote_destination entity. You must set the "target" field, and 
# create an object with a "targetname" field that matches.
# 
def trigger_voteexit(*qwp_extra):
    subs.InitTrigger()
    qc.self.touch = voteexit_touch
    qc.self.cnt = 0
    

def qwp_reset_ctfgame(*qwp_extra):
    global VOTEEXIT_TIME_LIMIT
    global voteexit_time
    global vote_leader
    global lastvotespawn
    
    VOTEEXIT_TIME_LIMIT = 60
    voteexit_time = 0
    vote_leader = engine.world
    lastvotespawn = engine.world
