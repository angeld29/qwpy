###
### Generated by QuakeC -> Python translator
### Id: qc2python.py,v 1.5 2001/02/05 21:15:44 barryp Exp 
###
### 2001-02-17 Cleaned up translation (barryp)
from qwpython.qwsv import engine, Vector
from qwpython.qcsupport import qc

import defs
import combat
import random
import items
import subs
import weapons
import status

# ***************************************************************************
#  * ThreeWave Capture The Flag
#  ****************************************************************************
#  * Based on John Spikles Complete Enhanced Teamplay
#  ****************************************************************************
#  * Version 4.0 rewrite Mar 21, 1997
#  ***************************************************************************
# * Defs *

# * MODIFIABLE CONSTANTS *
TEAM_DEFAULT_PENALTY = 1 #  Default frag penalty
TEAM_STRICT_COOP     = 0 #  Strict Coop

#  Team colors
TEAM_COLOR1 = 4
TEAM_COLOR2 = 13

# * End of MODIFIABLE CONSTANTS *

#  Globals
team1_lastspawn = engine.world
team2_lastspawn = engine.world
nextteamupdtime     = 0 #  time until next team update
last_flag_capture   = 0 #  time of last capture
last_capture_team   = 0 #  last team that captured
teamscr1            = 0 #  team 1's teamscr score
teamscr2            = 0 #  team 2's teamscr score
lastteamscrtime     = 0 #  last time we calculated it
TEAMSCRTIME = 1

#  Teamplay bitfield entries
TEAM_HEALTH_PROTECT     = 1 #  No health damage from friendly fire
TEAM_ARMOR_PROTECT      = 2 #  No armor damage from friendly fire
TEAM_ATTACKER_DAMAGE    = 4 #  Attacker takes damage from hitting teammates
TEAM_FRAG_PENALTY       = 8 #  One frag penalty for killing teammate
TEAM_DEATH_PENALTY      = 16 #  Die when you kill a teammate.
TEAM_LOCK_COLORS        = 32 #  Allow only team colors
TEAM_STATIC_TEAMS       = 64 #  Don't allow players to switch teams
TEAM_DROP_ITEMS         = 128 #  Allow players to drop packs and 
TEAM_CAPTURE_FLAG       = 256 #  Play capture the flag
TEAM_DISABLE_GRAPPLE    = 2048 #  team selection

TEAM_CAPTURE_CAPTURE_BONUS      = 15 #  what you get for capture
TEAM_CAPTURE_TEAM_BONUS         = 10 #  what your team gets for capture
TEAM_CAPTURE_RECOVERY_BONUS     = 1  #  what you get for recovery
TEAM_CAPTURE_FLAG_BONUS         = 0  #  what you get for picking up enemy flag
TEAM_CAPTURE_FRAG_CARRIER_BONUS = 2  #  what you get for fragging
                                     # enemy flag carrier
                                     
TEAM_CAPTURE_FLAG_RETURN_TIME = 40 #  seconds until auto return

#  XXX EXPERT CTF Additional scoring system
#  bonuses
TEAM_CAPTURE_CARRIER_DANGER_PROTECT_BONUS = 2 #  bonus for fraggin someone
                                              #  who has recently hurt your flag carrier
TEAM_CAPTURE_CARRIER_PROTECT_BONUS        = 1 #  bonus for fraggin someone while
                                              #  either you or your target are near your flag carrier
TEAM_CAPTURE_FLAG_DEFENSE_BONUS           = 1 #  bonus for fraggin someone while
                                              #  either you or your target are near your flag
TEAM_CAPTURE_RETURN_FLAG_ASSIST_BONUS     = 1 #  awarded for returning a flag that causes a
                                              #  capture to happen almost immediately
TEAM_CAPTURE_FRAG_CARRIER_ASSIST_BONUS    = 2 #  award for fragging a flag carrier if a
                                              #  capture happens almost immediately
                                              
#  radii
TEAM_CAPTURE_TARGET_PROTECT_RADIUS   = 400 #  the radius around an object being
                                           #  defended where a target will be worth extra frags
TEAM_CAPTURE_ATTACKER_PROTECT_RADIUS = 400 #  the radius around an object being
                                           #  defended where an attacker will get extra frags when making kills
#  timeouts
TEAM_CAPTURE_CARRIER_DANGER_PROTECT_TIMEOUT = 4
TEAM_CAPTURE_CARRIER_FLAG_SINCE_TIMEOUT     = 2
TEAM_CAPTURE_FRAG_CARRIER_ASSIST_TIMEOUT    = 6
TEAM_CAPTURE_RETURN_FLAG_ASSIST_TIMEOUT     = 4
TEAM_CAPTURE_UPDATE_TIME                    = 120

#  END EXPERT CTF

#  flag status used in cnt field of flag
FLAG_AT_BASE = 0
FLAG_CARRIED = 1
FLAG_DROPPED = 2

team_color_list = (('Grey',          'grey'),
                   ('Brown',         'brwn'),
                   ('Steel blue',    'sblu'),
                   ('Green',         'grn'),
                   ('Red',           'red'),
                   ('Olive',         'olve'),
                   ('Orange',        'orng'),
                   ('Peech',         'pch'), #sic
                   ('Purple',        'purp'),
                   ('Majenta',       'majn'), #sic
                   ('Tan',           'tan'),
                   ('Aqua',          'aqua'),
                   ('Yellow',        'ylw'),
                   ('Blue',          'blue'),
                   ('Bright Orange', 'bojn'),
                   ('Bright Red',    'bred'))
                                      
#
#  Return a name for the color of a team
#
def GetTeamColor(Team, *qwp_extra):
    return team_color_list[Team & 15][0]
 
 
#    
#  Return a name for the color of a team
#
def GetShortTeamColor(Team, *qwp_extra):
    return team_color_list[Team & 15][1]
    
    
#  *XXX* EXPERT CTF
#  Just a quickie to return the ASCII-ized team names for CTF
#
def GetCTFTeam(Team, *qwp_extra):
    if Team == TEAM_COLOR1:
        return '\322\305\304'
    if Team == TEAM_COLOR2:
        return '\302\314\325\305'
    return None
 
    
# 
# ================
# TeamPrintSettings
# 
# Print out current teamplay options
# ================
# 
def TeamPrintSettings(*qwp_extra):
    qc.self.sprint(defs.PRINT_HIGH, 'The following Teamplay options are set:\012')
    if defs.teamplay < 0:
        qc.self.sprint(defs.PRINT_HIGH, 'Frag penalty manually set to ')
        s = str(defs.teamplay)
        qc.self.sprint(defs.PRINT_HIGH, s)
        qc.self.sprint(defs.PRINT_HIGH, '\012')
        return 
        
    if not defs.teamplay:
        qc.self.sprint(defs.PRINT_HIGH, 'None\012')
        return 
        
    if 1 == defs.teamplay:
        qc.self.sprint(defs.PRINT_HIGH, "ID's original teamplay 1\012")
        return 
        
    if defs.teamplay & TEAM_HEALTH_PROTECT:
        qc.self.sprint(defs.PRINT_HIGH, 'Health-Protect ')
    if defs.teamplay & TEAM_ARMOR_PROTECT:
        qc.self.sprint(defs.PRINT_HIGH, 'Armor-Protect ')
    if defs.teamplay & TEAM_ATTACKER_DAMAGE:
        qc.self.sprint(defs.PRINT_HIGH, 'Mirror-Damage ')
    if defs.teamplay & TEAM_FRAG_PENALTY:
        qc.self.sprint(defs.PRINT_HIGH, 'Frag-Penalty ')
    if defs.teamplay & TEAM_DEATH_PENALTY:
        qc.self.sprint(defs.PRINT_HIGH, 'Death-Penalty ')
    if defs.teamplay & TEAM_LOCK_COLORS:
        qc.self.sprint(defs.PRINT_HIGH, 'Lock-Colors ')
    if defs.teamplay & TEAM_STATIC_TEAMS:
        qc.self.sprint(defs.PRINT_HIGH, 'Static-Teams ')
    if defs.teamplay & TEAM_DROP_ITEMS:
        qc.self.sprint(defs.PRINT_HIGH, 'Drop-Items (Backpack Impulse 20, Weapon Impulse 21) ')
    if defs.teamplay & TEAM_CAPTURE_FLAG:
        qc.self.sprint(defs.PRINT_HIGH, 'Capture-The-Flag ')
    qc.self.sprint(defs.PRINT_HIGH, '\012')

    
# 
# ================
# TeamArmorDam
# 
# Return TRUE if the target's armor can take damage from this attacker.
# ================
# 
def TeamArmorDam(targ, inflictor, attacker, damage, *qwp_extra):
    if defs.teamplay < 0 or defs.gamestart:
        return defs.TRUE
    if (defs.teamplay & TEAM_ARMOR_PROTECT) and attacker.steam == targ.steam and attacker != targ:
        #  Armor is protected
        return defs.FALSE        
    return defs.TRUE

    
# 
# ================
# TeamHealthDam
# 
# Return TRUE if the target can take health damage from this attacker.
# ================
# 
def TeamHealthDam(targ, inflictor, attacker, damage, *qwp_extra):
    if defs.teamplay < 0 or defs.gamestart:
        return defs.TRUE
        
    if attacker.steam == targ.steam and attacker != targ:
        #  Attacker and target are on the same team.
        if defs.teamplay & TEAM_ATTACKER_DAMAGE:
            #  Damage applied to teammate.
            combat.T_Damage(attacker, inflictor, attacker, damage)
            
        if defs.teamplay & TEAM_HEALTH_PROTECT:
            #  Health is protected
            return defs.FALSE
                    
    return defs.TRUE

    
# 
# ================
# TeamPFrags
# 
# Return the number of frags we should penalize attacker for killing targ.
# ================
# 
def TeamPFrags(targ, attacker, *qwp_extra):
    if defs.teamplay < 0:
        return (-1 * defs.teamplay)
    if targ != attacker and targ.steam == attacker.steam:
        #  targ and attacker are on the same team
        if defs.teamplay < 0:
            #  teamplay indicates frag penalty
            return (-1 * defs.teamplay)
            
        if defs.teamplay & TEAM_FRAG_PENALTY:
            #  default penalty
            return TEAM_DEFAULT_PENALTY
                    
    #  No frag penalty
    return 0

    
# 
# ================
# TeamFragPenalty
# 
# If attacker should be penalized for killing targ, penalize attacker
# and return TRUE.
# ================
# 
def TeamFragPenalty(targ, attacker, *qwp_extra):
    f = TeamPFrags(targ, attacker)
    if f:
        #  We should penalize some frags.
        attacker.frags -= f
        return defs.TRUE
        
    #  No penalty
    return defs.FALSE

    
# 
# =================
# TeamDeathPenalty
# 
# If attacker should be killed for killing targ, kill attacker and
# add a frag to offset the one attacker will lose for killing himself.
# 
def TeamDeathPenalty(targ, attacker, *qwp_extra):
    # Don't kill anyone if teamplay is negative.
    if defs.teamplay < 0:
        return 
    if (defs.teamplay & TEAM_DEATH_PENALTY) and attacker != targ and attacker.steam == targ.steam:
        # We should kill the attacker.
        combat.T_Damage(attacker, attacker, attacker, 1000)
        # Add a frag to offset the self-kill penalty.
        attacker.frags += 1
        
    
# 
# ==================
# TeamColorIsLegal
# 
# Return TRUE if the indicated color is legal
# ==================
# 
def TeamColorIsLegal(color, *qwp_extra):
    #  All colors are legal if teamplay is negative.
    if defs.teamplay < 0:
        return defs.TRUE
    #  All colors are legal if TEAM_LOCK_COLORS is off.
    if not (defs.teamplay & TEAM_LOCK_COLORS):
        return defs.TRUE
    if color == TEAM_COLOR1:
        return defs.TRUE
    if color == TEAM_COLOR2:
        return defs.TRUE
    return defs.FALSE
    

def TeamSkinSet(*qwp_extra):
    if qc.self.ctfskinno == 1:
        qc.self.ctfskin = 'ctfr1'
    elif qc.self.ctfskinno == 2:
        qc.self.ctfskin = 'ctfr2'
    elif qc.self.ctfskinno == 3:
        qc.self.ctfskin = 'ctfb1'
    elif qc.self.ctfskinno == 4:
        qc.self.ctfskin = 'ctfb2'
    elif qc.self.steam == TEAM_COLOR1:
        qc.self.ctfskin = 'ctfr1'
    elif qc.self.steam == TEAM_COLOR2:
        qc.self.ctfskin = 'ctfb1'
    else:
        qc.self.ctfskin = 'base'
    

def TeamSkinAssign(*qwp_extra):
    if not (defs.teamplay & TEAM_CAPTURE_FLAG):
        return 
    if qc.self.steam == TEAM_COLOR1:
        qc.self.ctfskinno = 1
    else:
        qc.self.ctfskinno = 3
    if random.random() < 0.5:
        qc.self.ctfskinno += 1
    qc.self.player_flag -= qc.self.player_flag & 65280
    qc.self.player_flag += qc.self.ctfskinno * 256
    TeamSkinSet()
    

def CrossDressCheck(tcolor, bcolor, *qwp_extra):
    #  All colors are legal is teamplay is negative.
    if defs.teamplay < 0:
        return defs.FALSE
    #  All colors are legal is TEAM_LOCK_COLORS is off.
    if not (defs.teamplay & TEAM_LOCK_COLORS):
        return defs.FALSE
    if tcolor == TEAM_COLOR1 and bcolor == TEAM_COLOR2:
        return defs.TRUE
    if tcolor == TEAM_COLOR2 and bcolor == TEAM_COLOR1:
        return defs.TRUE
    return defs.FALSE

    
# 
# ==================
# TeamAssign
# 
# Check if the team self is on is legal, and put self in a legal team if not.
# ==================
# 
def TeamAssign(*qwp_extra):
    if qc.self.steam >= 0:
        if TeamColorIsLegal(qc.self.steam):
            TeamSkinAssign()
            return 
            
    #  Assign the player to a team.
    #  Sum the players on all the teams.
    TEAM1 = 0
    TEAM2 = 0
    p = qc.find(qc.world, 'classname', 'player')
    while p:
        if p != qc.self and not (p.player_flag & defs.PF_GHOST):
            if p.steam == TEAM_COLOR1:
                TEAM1 += 1
            elif p.steam == TEAM_COLOR2:
                TEAM2 += 1            
        p = qc.find(p, 'classname', 'player')
        
    #  Find the team with the least players.
    if TEAM1 < TEAM2 or ((TEAM1 == TEAM2) and (random.random() < 0.5)):
        newcolor = TEAM_COLOR1
    else:
        newcolor = TEAM_COLOR2
        
    #  Put the player on a the new team.
    qc.self.sprint(defs.PRINT_HIGH, 'You have been assigned to ')
    n = GetTeamColor(newcolor)
    qc.self.sprint(defs.PRINT_HIGH, n)
    qc.self.sprint(defs.PRINT_HIGH, ' team.\012')
    qc.self.steam = newcolor
    TeamSkinAssign()
    qc.self.player_flag |= defs.TEAM_STUFF_COLOR
    
    
# 
# ===============
# TeamCheckLock
# 
# Check for team changing and perform whatever actions are neccessary.
# ===============
# 
def TeamCheckLock(*qwp_extra):
    n = 0
    s = None
    t = None
    pteam = 0
    #  Don't do anything if teamplay is negative
    if defs.teamplay < 0:
        return 
    if defs.gamestart:
        s = qc.self.infokey('bottomcolor')
        pteam = qc.stof(s)
        if pteam != 0:
            qc.self.stuffcmd('setinfo bottomcolor 0\012')
        qc.self.steam = -1
        return 
        
    if qc.self.player_flag & defs.TEAM_STUFF_COLOR:
        qc.self.player_flag -= defs.TEAM_STUFF_COLOR
        s = str(qc.self.steam)
        qc.self.stuffcmd('setinfo bottomcolor ')
        qc.self.stuffcmd(s)
        qc.self.stuffcmd('\012')
        s = qc.self.infokey('topcolor')
        n = qc.stof(s)
        if CrossDressCheck(n, qc.self.steam):
            s = str(qc.self.steam)
            qc.self.stuffcmd('setinfo topcolor ')
            qc.self.stuffcmd(s)
            qc.self.stuffcmd('\012')
            
        s = GetShortTeamColor(qc.self.steam)
        qc.self.stuffcmd('setinfo team ')
        qc.self.stuffcmd(s)
        qc.self.stuffcmd('\012')
        if defs.teamplay & TEAM_CAPTURE_FLAG:
            qc.self.stuffcmd('setinfo skin ')
            qc.self.stuffcmd(qc.self.ctfskin)
            qc.self.stuffcmd('\012')
            
        qc.self.lastteamset = qc.time
        return 
        
    s = qc.self.infokey('bottomcolor')
    pteam = qc.stof(s)
    #  Check to see if the player has changed skins
    if qc.self.steam > 0 and qc.time - qc.self.lastteamset > 2:
        if defs.teamplay & TEAM_CAPTURE_FLAG:
            if qc.self.infokey('skin') != qc.self.ctfskin:
                qc.self.stuffcmd('setinfo skin ')
                qc.self.stuffcmd(qc.self.ctfskin)
                qc.self.stuffcmd('\012')
                qc.self.lastteamset = qc.time
                
        s = GetShortTeamColor(qc.self.steam)
        if qc.self.infokey('team') != s:
            qc.self.stuffcmd('setinfo team ')
            qc.self.stuffcmd(s)
            qc.self.stuffcmd('\012')
            qc.self.lastteamset = qc.time
                    
    #  check for crossdressing
    s = qc.self.infokey('topcolor')
    n = qc.stof(s)
    if CrossDressCheck(n, qc.self.steam):
        s = str(qc.self.steam)
        qc.self.stuffcmd('setinfo topcolor ')
        qc.self.stuffcmd(s)
        qc.self.stuffcmd('\012')
        return 
        
    #  Check to see if the player has changed colors
    if qc.time - qc.self.lastteamset > 2 and pteam != qc.self.steam:
        #  Player has changed colors
        #  If teams are static and we've been on some team already,
        #  put us back on the team we were on.
        if (defs.teamplay & TEAM_STATIC_TEAMS) and (qc.self.steam >= 0):
            if TeamColorIsLegal(qc.self.steam):
                #  changing teams sucks, kill him
                #  if he has tried to change teams several
                #  times, kick him off the server.
                if qc.self.suicide_count > 3:
                    qc.self.sprint(defs.PRINT_HIGH, "You were told you can't change teams.\012Go play color games somewhere else.\012")
                    qc.self.stuffcmd('disconnect\012')
                    engine.bprint(defs.PRINT_MEDIUM, qc.self.netname)
                    engine.bprint(defs.PRINT_MEDIUM, ' has bad color sense\012')
                    
                #  case base respawn
                qc.self.killed = 99
                combat.T_Damage(qc.self, qc.self, qc.self, 1000) #  Kill the player
                qc.self.killed = 2
                #  trying to change teams counts as a suicide
                qc.self.suicide_count += 1
                qc.self.logfrag(qc.self) #  he pays for it
                qc.self.sprint(defs.PRINT_HIGH, 'You cannot change teams.\012')
                qc.self.stuffcmd('setinfo bottomcolor ')
                s = str(qc.self.steam)
                qc.self.stuffcmd(s)
                qc.self.stuffcmd('\012')
                qc.self.lastteamset = qc.time
                return                 
            else:
                #  If we're on an illegal team, force a change.
                qc.self.steam = -1                            
        elif not (defs.teamplay & TEAM_LOCK_COLORS):
            return 
        if qc.self.steam >= 0:
            #  case base respawn
            qc.self.killed = 99
            combat.T_Damage(qc.self, qc.self, qc.self, 1000) #  Kill the player
            qc.self.killed = 0
            
        qc.self.steam = pteam
        qc.self.frags = 0 #  Zero out frags
        TeamAssign()
        
    
# 
# =======================
# TossBackPack
# 
# Original idea by Vhold
# Rewritten by John Spickes
# 
# Toss out a backpack containing some ammo from your current weapon,
# and any weapons you don't have.
# =======================
# 
def TossBackpack(*qwp_extra):
    #  If we don't have any ammo, return (except AXE/GRAPPLE) 
    if qc.self.currentammo <= 0:
        if qc.self.weapon != defs.IT_AXE and qc.self.weapon != defs.IT_GRAPPLE:
            return 
        
    item = qc.spawn()
    #  See if you have the Shotgun or Super Shotgun on
    if (qc.self.weapon == defs.IT_SHOTGUN) or (qc.self.weapon == defs.IT_SUPER_SHOTGUN):
        if qc.self.ammo_shells >= 20:
            item.ammo_shells = 20
            qc.self.ammo_shells -= 20            
        else:
            item.ammo_shells = qc.self.ammo_shells
            qc.self.ammo_shells = 0
                    
    #  See if you have neither the Shotgun or Super Shotgun
    if not (qc.self.items & defs.IT_SHOTGUN) and not (qc.self.items & defs.IT_SUPER_SHOTGUN):
        if qc.self.ammo_shells >= 20:
            item.ammo_shells = 20
            qc.self.ammo_shells -= 20            
        else:
            item.ammo_shells = qc.self.ammo_shells
            qc.self.ammo_shells = 0
                    
    #  See if we are using a nailgun
    if (qc.self.weapon == defs.IT_NAILGUN) or (qc.self.weapon == defs.IT_SUPER_NAILGUN):
        if qc.self.ammo_nails >= 20:
            item.ammo_nails = 20
            qc.self.ammo_nails -= 20            
        else:
            item.ammo_nails = qc.self.ammo_nails
            qc.self.ammo_nails = 0
                    
    #  Check to see if we have neither nailgun
    if not (qc.self.items & defs.IT_NAILGUN) and not (qc.self.items & defs.IT_SUPER_NAILGUN):
        if qc.self.ammo_nails >= 20:
            item.ammo_nails = 20
            qc.self.ammo_nails -= 20            
        else:
            item.ammo_nails = qc.self.ammo_nails
            qc.self.ammo_nails = 0
                    
    #  See if we are using a grenade or rocket launcher
    if (qc.self.weapon == defs.IT_GRENADE_LAUNCHER) or (qc.self.weapon == defs.IT_ROCKET_LAUNCHER):
        if qc.self.ammo_rockets >= 10:
            item.ammo_rockets = 10
            qc.self.ammo_rockets -= 10            
        else:
            item.ammo_rockets = qc.self.ammo_rockets
            qc.self.ammo_rockets = 0
                    
    #  See if we have neither the Grenade or rocket launcher
    if not (qc.self.items & defs.IT_GRENADE_LAUNCHER) and not (qc.self.items & defs.IT_ROCKET_LAUNCHER):
        if qc.self.ammo_rockets >= 10:
            item.ammo_rockets = 10
            qc.self.ammo_rockets -= 10            
        else:
            item.ammo_rockets = qc.self.ammo_rockets
            qc.self.ammo_rockets = 0
                    
    #  See if we're using the lightning gun
    if qc.self.weapon == defs.IT_LIGHTNING:
        if qc.self.ammo_cells >= 20:
            item.ammo_cells = 20
            qc.self.ammo_cells -= 20            
        else:
            item.ammo_cells = qc.self.ammo_cells
            qc.self.ammo_cells = 0            
        
    #  see if we don't have the lightning gun
    if not (qc.self.items & defs.IT_LIGHTNING):
        if qc.self.ammo_cells >= 20:
            item.ammo_cells = 20
            qc.self.ammo_cells -= 20            
        else:
            item.ammo_cells = qc.self.ammo_cells
            qc.self.ammo_cells = 0
                    
    if not item.ammo_shells and not item.ammo_nails and not item.ammo_rockets and not item.ammo_cells:
        #  we didn't put anything in
        item.remove()
        return 
        
    item.owner = qc.self
    qc.makevectors(qc.self.v_angle)
    qc.setorigin(item, qc.self.origin + Vector(0, 0, 16))
    item.velocity = qc.self.aim(1000)
    item.velocity *= 500
    item.flags = defs.FL_ITEM
    item.solid = defs.SOLID_TRIGGER
    item.movetype = defs.MOVETYPE_BOUNCE
    item.setmodel('progs/backpack.mdl')
    qc.setsize(item, Vector(-16, -16, 0), Vector(16, 16, 56))
    item.touch = items.BackpackTouch
    item.nextthink = qc.time + 120 #  remove after 2 minutes
    item.think = subs.SUB_Remove
    weapons.W_SetCurrentAmmo()
    

def Team_weapon_touch(*qwp_extra):
    if not (qc.other.flags & defs.FL_CLIENT):
        return 
        
    #  Don't let the owner pick up his own weapon for a second.
    if (qc.other == qc.self.owner) and ((qc.self.nextthink - qc.time) > 119):
        return 
        
    #  if the player was using his best weapon, change up to the new one if better		
    stemp = qc.self
    qc.self = qc.other
    best = weapons.W_BestWeapon()
    qc.self = stemp
    
    if qc.self.classname == 'weapon_nailgun':
        hadammo = qc.other.ammo_nails
        new = defs.IT_NAILGUN        
    elif qc.self.classname == 'weapon_supernailgun':
        hadammo = qc.other.ammo_rockets
        new = defs.IT_SUPER_NAILGUN        
    elif qc.self.classname == 'weapon_supershotgun':
        hadammo = qc.other.ammo_rockets
        new = defs.IT_SUPER_SHOTGUN        
    elif qc.self.classname == 'weapon_rocketlauncher':
        hadammo = qc.other.ammo_rockets
        new = defs.IT_ROCKET_LAUNCHER        
    elif qc.self.classname == 'weapon_grenadelauncher':
        hadammo = qc.other.ammo_rockets
        new = defs.IT_GRENADE_LAUNCHER        
    elif qc.self.classname == 'weapon_lightning':
        hadammo = qc.other.ammo_rockets
        new = defs.IT_LIGHTNING        
    else:
        qc.objerror('Team_weapon_touch: unknown classname')
        
    qc.other.sprint(defs.PRINT_LOW, 'You got the ')
    qc.other.sprint(defs.PRINT_LOW, qc.self.netname)
    qc.other.sprint(defs.PRINT_LOW, '\012')
    #  weapon touch sound
    qc.other.sound(defs.CHAN_ITEM, 'weapons/pkup.wav', 1, defs.ATTN_NORM)
    qc.other.stuffcmd('bf\012')
    items.bound_other_ammo()
    #  change to the weapon
    old = qc.other.items
    qc.other.items |= new
    qc.self.remove()
    qc.self = qc.other
    if not defs.deathmatch:
        qc.self.weapon = new
    else:
        items.Deathmatch_Weapon(old, new)
    weapons.W_SetCurrentAmmo()
    defs.activator = qc.other
    subs.SUB_UseTargets() #  fire all targets / killtargets
    

def TossWeapon(*qwp_extra):
    if defs.deathmatch != 1:
        return  #  only in deathmatch 1
    if (qc.self.weapon == defs.IT_AXE) or (qc.self.weapon == defs.IT_SHOTGUN) or (qc.self.weapon == defs.IT_GRAPPLE):
        return 
    item = qc.spawn()
    item.owner = qc.self
    qc.makevectors(qc.self.v_angle)
    qc.setorigin(item, qc.self.origin + Vector(0, 0, 16))
    item.velocity = qc.self.aim(1000)
    item.velocity *= 500
    item.flags = defs.FL_ITEM
    item.solid = defs.SOLID_TRIGGER
    item.movetype = defs.MOVETYPE_BOUNCE
    
    if qc.self.weapon == defs.IT_SUPER_SHOTGUN:
        item.setmodel('progs/g_shot.mdl')
        item.weapon = defs.IT_SUPER_SHOTGUN
        item.netname = 'Double-barrelled Shotgun'
        item.classname = 'weapon_supershotgun'
        qc.self.items -= defs.IT_SUPER_SHOTGUN        
    elif qc.self.weapon == defs.IT_NAILGUN:
        item.setmodel('progs/g_nail.mdl')
        item.weapon = defs.IT_NAILGUN
        item.netname = 'nailgun'
        item.classname = 'weapon_nailgun'
        qc.self.items -= defs.IT_NAILGUN        
    elif qc.self.weapon == defs.IT_SUPER_NAILGUN:
        item.setmodel('progs/g_nail2.mdl')
        item.weapon = defs.IT_SUPER_NAILGUN
        item.netname = 'Super Nailgun'
        item.classname = 'weapon_supernailgun'
        qc.self.items -= defs.IT_SUPER_NAILGUN        
    elif qc.self.weapon == defs.IT_GRENADE_LAUNCHER:
        item.setmodel('progs/g_rock.mdl')
        item.weapon = 3
        item.netname = 'Grenade Launcher'
        item.classname = 'weapon_grenadelauncher'
        qc.self.items -= defs.IT_GRENADE_LAUNCHER        
    elif qc.self.weapon == defs.IT_ROCKET_LAUNCHER:
        item.setmodel('progs/g_rock2.mdl')
        item.weapon = 3
        item.netname = 'Rocket Launcher'
        item.classname = 'weapon_rocketlauncher'
        qc.self.items -= defs.IT_ROCKET_LAUNCHER        
    elif qc.self.weapon == defs.IT_LIGHTNING:
        item.setmodel('progs/g_light.mdl')
        item.weapon = 3
        item.netname = 'Thunderbolt'
        item.classname = 'weapon_lightning'
        qc.self.items -= defs.IT_LIGHTNING
        
    qc.setsize(item, Vector(-16, -16, 0), Vector(16, 16, 56))
    item.touch = Team_weapon_touch
    item.think = subs.SUB_Remove
    item.nextthink = qc.time + 120
    qc.self.weapon = weapons.W_BestWeapon()
    weapons.W_SetCurrentAmmo()
    

def RegenFlag(flg, *qwp_extra):
    flg.movetype = defs.MOVETYPE_TOSS
    flg.solid = defs.SOLID_TRIGGER
    flg.setmodel(flg.mdl)
    qc.setorigin(flg, flg.oldorigin)
    flg.angles = flg.mangle
    flg.cnt = FLAG_AT_BASE #  it's at home base
    flg.owner = qc.world
    flg.velocity = Vector(0, 0, 0)
    flg.sound(defs.CHAN_VOICE, 'items/itembk2.wav', 1, defs.ATTN_NORM) #  play respawn sound
    

def TeamCaptureReturnFlag(flg, *qwp_extra):
    RegenFlag(flg)
    p = qc.find(qc.world, 'classname', 'player')
    while p != qc.world:
        if p.steam != flg.steam:
            status.TeamPlayerUpdate(p, 'Enemy flag has been returned to base!')
        elif p.steam == flg.steam:
            status.TeamPlayerUpdate(p, 'Your flag has been returned to base!')
        p = qc.find(p, 'classname', 'player')
        
    
def TeamCaptureRegenFlags(*qwp_extra):
    f = qc.find(qc.world, 'classname', 'item_flag_team1')
    if f != qc.world:
        RegenFlag(f)
    f = qc.find(qc.world, 'classname', 'item_flag_team2')
    if f != qc.world:
        RegenFlag(f)
    

def TeamDropFlag(flg, *qwp_extra):
    p = flg.owner
    engine.bprint(defs.PRINT_HIGH, p.netname)
    if p.steam == TEAM_COLOR1:
        engine.bprint(defs.PRINT_HIGH, ' \354\357\363\364 the \302\314\325\305 flag!\012') #  blue
    else:
        engine.bprint(defs.PRINT_HIGH, ' \354\357\363\364 the \322\305\304 flag!\012') #  red
    p.effects -= p.effects & (defs.EF_FLAG1 | defs.EF_FLAG2)
    flg.origin = p.origin - Vector(0, 0, 24)
    flg.cnt = FLAG_DROPPED
    flg.velocity %= Vector(None, None, 300)
    flg.velocity %= Vector(0, None, None)
    flg.velocity %= Vector(None, 0, None)
    flg.flags = defs.FL_ITEM
    flg.solid = defs.SOLID_TRIGGER
    flg.movetype = defs.MOVETYPE_TOSS
    flg.setmodel(flg.mdl)
    qc.setsize(qc.self, Vector(-16, -16, 0), Vector(16, 16, 74))
    #  return it after so long
    flg.super_time = qc.time + TEAM_CAPTURE_FLAG_RETURN_TIME
    

def TeamCaptureDropFlagOfPlayer(player, *qwp_extra):
    if not (player.player_flag & defs.ITEM_ENEMY_FLAG):
        return 
    if player.steam == TEAM_COLOR1:
        kn = 'item_flag_team2'
    else:
        kn = 'item_flag_team1'
    player.player_flag -= defs.ITEM_ENEMY_FLAG
    e = qc.find(qc.world, 'classname', kn)
    if e != qc.world:
        TeamDropFlag(e)

    
#  possum: 3 loops in one.  Hopefully this will help prevent an
#  occasional server lockup when a player picks up and then captures the
#  flag in rapid succession
#
def LoopThroughPlayersAfterCapture(*qwp_extra):
    global lastteamscrtime
    global teamscr1
    global teamscr2
    
    #  count up teamscr
    lastteamscrtime = qc.time + TEAMSCRTIME
    teamscr1 = teamscr2 = 0
    
    #  Ok, let's do the player loop, hand out the bonuses, add up
    #  the scores, and inform the players about the capture
    p = qc.find(qc.world, 'classname', 'player')
    while p != qc.world:
        #  Ok, let's do the player loop, hand out the bonuses
        qc.self = p
        qc.self.killed = 0
        if qc.self.steam == qc.other.steam and qc.self != qc.other:
            qc.self.frags += TEAM_CAPTURE_TEAM_BONUS
        if qc.self.steam != qc.other.steam:
            #  *XXX* EXPERT CTF
            #  reset the last_hurt_carrier variable in all enemy
            #  players, so that you don't get bonuses for defending
            #  the flag carrier if the flag carrier has already
            #  completed a capture
            qc.self.last_hurt_carrier = -5            
        elif qc.self.steam == qc.other.steam:
            #  done to all players on the capturing team
            #  *XXX* EXPERT CTF
            #  award extra points for capture assists
            if qc.self.last_returned_flag + TEAM_CAPTURE_RETURN_FLAG_ASSIST_TIMEOUT > qc.time:
                engine.bprint(defs.PRINT_HIGH, qc.self.netname)
                engine.bprint(defs.PRINT_HIGH, ' gets an assist for returning his flag!\012')
                qc.self.frags += TEAM_CAPTURE_RETURN_FLAG_ASSIST_BONUS
                
            if qc.self.last_fragged_carrier + TEAM_CAPTURE_FRAG_CARRIER_ASSIST_TIMEOUT > qc.time:
                engine.bprint(defs.PRINT_HIGH, qc.self.netname)
                engine.bprint(defs.PRINT_HIGH, ' gets an assist for fragging the flag carrier!\012')
                qc.self.frags += TEAM_CAPTURE_FRAG_CARRIER_ASSIST_BONUS
                            
        qc.self.player_flag -= qc.self.player_flag & defs.ITEM_ENEMY_FLAG
        #  count up teamscr
        if p.steam == TEAM_COLOR1:
            teamscr1 += p.frags
        elif p.steam == TEAM_COLOR2:
            teamscr2 += p.frags
        #  inform players about capture
        if (p.steam == TEAM_COLOR1 and qc.other.steam == TEAM_COLOR2) or (p.steam == TEAM_COLOR2 and qc.other.steam == TEAM_COLOR1):
            status.TeamPlayerUpdate(p, 'Your flag was captured!')
        elif p.steam == qc.other.steam:
            status.TeamPlayerUpdate(p, 'Your team captured the flag!')
        #  remove any flags
        p.effects -= p.effects & (defs.EF_FLAG1 | defs.EF_FLAG2)
        p = qc.find(p, 'classname', 'player')
        
    
def TeamCaptureFlagTouch(*qwp_extra):
    global last_flag_capture
    global last_capture_team
    
    if qc.other.classname != 'player':
        return 
    if qc.other.health <= 0:
        return 
        
    if qc.self.steam == qc.other.steam:
        #  same team, if the flag is *not* at the base, return
        #  it to base.  we overload the 'cnt' field for this
        if qc.self.cnt == FLAG_AT_BASE:
            #  the flag is at home base.  if the player has the enemy
            #  flag, he's just won!
            if qc.other.player_flag & defs.ITEM_ENEMY_FLAG:
                engine.bprint(defs.PRINT_HIGH, qc.other.netname)
                if qc.other.steam == TEAM_COLOR1:
                    engine.bprint(defs.PRINT_HIGH, ' \343\341\360\364\365\362\345\344 the \302\314\325\305 flag!\012') #  blue
                else:
                    engine.bprint(defs.PRINT_HIGH, ' \343\341\360\364\365\362\345\344 the \322\305\304 flag!\012') #  red
                qc.other.items -= qc.other.items & (defs.IT_KEY1 | defs.IT_KEY2)
                last_flag_capture = qc.time
                last_capture_team = qc.other.steam
                qc.other.sound(defs.CHAN_VOICE, 'misc/flagcap.wav', 1, defs.ATTN_NONE)
                #  other gets another 10 frag bonus
                qc.other.frags += TEAM_CAPTURE_CAPTURE_BONUS
                #  possum: 3 loops in one
                LoopThroughPlayersAfterCapture()
                #  respawn flags
                TeamCaptureRegenFlags()
                return 
                
            return  #  its at home base already
            
        #  hey, its not home.  return it by teleporting it back
        engine.bprint(defs.PRINT_HIGH, qc.other.netname)
        if qc.other.steam == TEAM_COLOR1:
            engine.bprint(defs.PRINT_HIGH, ' \362\345\364\365\362\356\345\344 the \322\305\304 flag!\012') #  red
        else:
            engine.bprint(defs.PRINT_HIGH, ' \362\345\364\365\362\356\345\344 the \302\314\325\305 flag!\012') #  blue
        qc.other.frags += TEAM_CAPTURE_RECOVERY_BONUS
        #  *XXX* EXPERT CTF set time when player last returned his flag
        qc.other.last_returned_flag = qc.time
        qc.other.sound(defs.CHAN_ITEM, qc.self.noise1, 1, defs.ATTN_NORM)
        TeamCaptureReturnFlag(qc.self)
        return 
        
    #  hey, its not our flag, pick it up
    engine.bprint(defs.PRINT_HIGH, qc.other.netname)
    if qc.other.steam == TEAM_COLOR1:
        engine.bprint(defs.PRINT_HIGH, ' \347\357\364 the \302\314\325\305 flag!\012') #  blue
    else:
        engine.bprint(defs.PRINT_HIGH, ' \347\357\364 the \322\305\304 flag!\012') #  red
    if TEAM_CAPTURE_FLAG_BONUS:
        qc.other.frags += TEAM_CAPTURE_FLAG_BONUS
    # 	TeamPlayerUpdate(other, "YOU GOT THE ENEMY FLAG!\n\nRETURN TO BASE!");
    status.TeamPlayerUpdate(qc.other, '\331\317\325 \307\317\324 \324\310\305 \305\316\305\315\331 \306\314\301\307\012\012\322\305\324\325\322\316 \324\317 \302\301\323\305')
    qc.other.sound(defs.CHAN_ITEM, qc.self.noise, 1, defs.ATTN_NORM)
    qc.other.player_flag += defs.ITEM_ENEMY_FLAG
    qc.other.items |= qc.self.items
    #  *XXX* EXPERT CTF set the time at which the carrier picked up the flag
    qc.other.flag_since = qc.time
    #  pick up the flag
    qc.self.cnt = FLAG_CARRIED
    qc.self.solid = defs.SOLID_NOT
    qc.self.owner = qc.other
    if qc.self.steam == TEAM_COLOR1:
        qc.self.owner.effects |= defs.EF_FLAG1
    else: #  must be other team
        qc.self.owner.effects |= defs.EF_FLAG2
    qc.self.setmodel(None)
    p = qc.find(qc.world, 'classname', 'player')
    while p != qc.world:
        if p != qc.other:
            if p.steam != qc.other.steam:
                status.TeamPlayerUpdate(p, 'Your flag has been taken!')
            elif p.steam == qc.other.steam:
                status.TeamPlayerUpdate(p, 'Your team has the enemy flag!')            
        p = qc.find(p, 'classname', 'player')
        
    
def TeamCaptureFlagThink(*qwp_extra):
    qc.self.nextthink = qc.time + 0.1
    if qc.self.cnt == FLAG_AT_BASE:
        return  #  just sitting around waiting to be picked up
    if qc.self.cnt == FLAG_DROPPED:
        if qc.time - qc.self.super_time > TEAM_CAPTURE_FLAG_RETURN_TIME:
            TeamCaptureReturnFlag(qc.self)
        return         
    if qc.self.cnt != FLAG_CARRIED:
        qc.objerror('Flag in invalid state\012')

    
#    
#  self is player
#
def TeamCaptureSpawn(*qwp_extra):
    global team1_lastspawn
    global team2_lastspawn
    
    if not (defs.teamplay & TEAM_CAPTURE_FLAG):
        return qc.world
    if qc.self.steam == TEAM_COLOR1:
        team1_lastspawn = qc.find(team1_lastspawn, 'classname', 'info_player_team1')
        if team1_lastspawn == qc.world:
            team1_lastspawn = qc.find(team1_lastspawn, 'classname', 'info_player_team1')
        return team1_lastspawn        
    elif qc.self.steam == TEAM_COLOR2:
        team2_lastspawn = qc.find(team2_lastspawn, 'classname', 'info_player_team2')
        if team2_lastspawn == qc.world:
            team2_lastspawn = qc.find(team2_lastspawn, 'classname', 'info_player_team2')
        return team2_lastspawn
        
    return qc.world
    
    
# 
# 	From byron@caseware.com Wed Oct 16 18:57:44 1996
# 	Date: Wed, 16 Oct 1996 21:22:37 -0400
# 	From: Byron Long <byron@caseware.com>
# 	To: zoid@mindlink.net
# 	Subject: Team Status Command (source code included) :-)
# 
# 	A co-worker of mine wondered if it was possible to add a function to
# 	your capture the flag code that would give a status report on an
# 	impulse. I think he may have mailed you, but I wrote a quick version
# 	myself, which your welcome to use if you like the feature (it offsets
# 	some of the problems with the chat capabilities in Quake so it seems
# 	like a worthwhile feature). Feel free to change it
# 	as necessary.
# 
#  *Capture The Flag - Status report by Wonko
#
def TeamFlagStatusReport(*qwp_extra):
    if not (defs.teamplay & TEAM_CAPTURE_FLAG):
        qc.self.sprint(defs.PRINT_HIGH, 'Capture the Flag is not enabled.\012')
        return 
        
    #  Find the flags at home base
    flag1 = qc.find(qc.world, 'classname', 'item_flag_team1')
    flag2 = qc.find(qc.world, 'classname', 'item_flag_team2')
    if qc.self.classname == 'spectator':
        if flag1 != qc.world and flag1.cnt == FLAG_CARRIED:
            qc.self.sprint(defs.PRINT_HIGH, flag1.owner.netname)
            qc.self.sprint(defs.PRINT_HIGH, ' has the \322\305\304 flag.\012')            
        else:
            qc.self.sprint(defs.PRINT_HIGH, 'The \322\305\304 flag is ')
            if flag1 == qc.world:
                qc.self.sprint(defs.PRINT_HIGH, 'missing!\012')
            if flag1.cnt == FLAG_AT_BASE:
                qc.self.sprint(defs.PRINT_HIGH, 'at base.\012')
            elif flag1.cnt == FLAG_DROPPED:
                qc.self.sprint(defs.PRINT_HIGH, 'lying about.\012')
            else:
                qc.self.sprint(defs.PRINT_HIGH, ' corrupt.\012')
            
        if flag2 != qc.world and flag2.cnt == FLAG_CARRIED:
            qc.self.sprint(defs.PRINT_HIGH, flag2.owner.netname)
            qc.self.sprint(defs.PRINT_HIGH, ' has the \302\314\325\305 flag. ')            
        else:
            qc.self.sprint(defs.PRINT_HIGH, 'The \302\314\325\305 flag is ')
            if flag2 == qc.world:
                qc.self.sprint(defs.PRINT_HIGH, 'missing!\012')
            if flag2.cnt == FLAG_AT_BASE:
                qc.self.sprint(defs.PRINT_HIGH, 'at base.\012')
            elif flag2.cnt == FLAG_DROPPED:
                qc.self.sprint(defs.PRINT_HIGH, 'lying about.\012')
            else:
                qc.self.sprint(defs.PRINT_HIGH, ' corrupt.\012')            
        return 
        
    #  If on team 2 switch meanings of flags
    if qc.self.steam != TEAM_COLOR1:
        p = flag1
        flag1 = flag2
        flag2 = p
        
    if flag1 != qc.world and flag1.cnt == FLAG_CARRIED:
        qc.self.sprint(defs.PRINT_HIGH, flag1.owner.netname)
        qc.self.sprint(defs.PRINT_HIGH, ' has your flag. ')        
    else:
        qc.self.sprint(defs.PRINT_HIGH, 'Your flag is ')
        if flag1 == qc.world:
            qc.self.sprint(defs.PRINT_HIGH, 'missing! ')
        if flag1.cnt == FLAG_AT_BASE:
            qc.self.sprint(defs.PRINT_HIGH, 'in your base. ')
        elif flag1.cnt == FLAG_DROPPED:
            qc.self.sprint(defs.PRINT_HIGH, 'lying about. ')
        else:
            qc.self.sprint(defs.PRINT_HIGH, ' corrupt. ')
        
    if flag2 != qc.world and flag2.cnt == FLAG_CARRIED:
        if qc.self == flag2.owner:
            qc.self.sprint(defs.PRINT_HIGH, 'You have the enemy flag.\012')
        else:
            qc.self.sprint(defs.PRINT_HIGH, flag2.owner.netname)
            qc.self.sprint(defs.PRINT_HIGH, ' has the enemy flag.\012')                    
    else:
        qc.self.sprint(defs.PRINT_HIGH, 'The enemy flag is ')
        if flag2 == qc.world:
            qc.self.sprint(defs.PRINT_HIGH, 'missing!\012')
        if flag2.cnt == FLAG_AT_BASE:
            qc.self.sprint(defs.PRINT_HIGH, 'in their base.\012')
        elif flag2.cnt == FLAG_DROPPED:
            qc.self.sprint(defs.PRINT_HIGH, 'lying about.\012')
        else:
            qc.self.sprint(defs.PRINT_HIGH, ' corrupt.\012')
        
    
# ///////////////////////////////////////////////////////////////////////

def place_flag(*qwp_extra):
    qc.self.mdl = qc.self.model #  so it can be restored on respawn
    qc.self.flags = defs.FL_ITEM #  make extra wide
    qc.self.solid = defs.SOLID_TRIGGER
    qc.self.movetype = defs.MOVETYPE_TOSS
    qc.self.velocity = Vector(0, 0, 0)
    qc.self.origin %= Vector(None, None, qc.self.origin.z + 6)
    qc.self.think = TeamCaptureFlagThink
    qc.self.touch = TeamCaptureFlagTouch
    qc.self.nextthink = qc.time + 0.1
    qc.self.cnt = FLAG_AT_BASE
    qc.self.mangle = qc.self.angles
    qc.self.effects |= defs.EF_DIMLIGHT
    if not qc.droptofloor():
        engine.dprint('Flag fell out of level at ')
        engine.dprint(str(qc.self.origin))
        engine.dprint('\012')
        qc.self.remove()
        return 
        
    qc.self.oldorigin = qc.self.origin #  save for flag return

    
#  ZOID Capture the flag

def item_flag_team1(*qwp_extra):
    if not defs.deathmatch or not (engine.cvar('teamplay') & TEAM_CAPTURE_FLAG):
        qc.self.remove()
        return 
        
    qc.self.steam = TEAM_COLOR1
    qc.self.items = defs.IT_KEY2
    engine.precache_model('progs/flag.mdl')
    qc.self.setmodel('progs/flag.mdl')
    qc.self.skin = 0
    engine.precache_sound('misc/flagtk.wav') #  flag taken
    engine.precache_sound('misc/flagcap.wav') #  flag capture
    engine.precache_sound('doors/runetry.wav')
    qc.self.noise = 'misc/flagtk.wav'
    qc.self.noise1 = 'doors/runetry.wav'
    qc.setsize(qc.self, Vector(-16, -16, 0), Vector(16, 16, 74))
    qc.self.nextthink = qc.time + 0.2 #  items start after other solids
    qc.self.think = place_flag
    

def item_flag_team2(*qwp_extra):
    if not defs.deathmatch or not (engine.cvar('teamplay') & TEAM_CAPTURE_FLAG):
        qc.self.remove()
        return 
        
    qc.self.steam = TEAM_COLOR2
    qc.self.items = defs.IT_KEY1
    engine.precache_model('progs/flag.mdl')
    qc.self.setmodel('progs/flag.mdl')
    qc.self.skin = 1
    engine.precache_sound('misc/flagtk.wav') #  flag taken
    engine.precache_sound('misc/flagcap.wav') #  flag capture
    engine.precache_sound('doors/runetry.wav')
    qc.self.noise = 'misc/flagtk.wav'
    qc.self.noise1 = 'doors/runetry.wav'
    qc.setsize(qc.self, Vector(-16, -16, 0), Vector(16, 16, 74))
    #  make it glow
    qc.self.nextthink = qc.time + 0.2 #  items start after other solids
    qc.self.think = place_flag

    
#  Team base starting locations

def info_player_team1(*qwp_extra):
    pass


def info_player_team2(*qwp_extra):
    pass
    
    
# QUAKED func_ctf_wall (0 .5 .8) ?
# This is just a solid wall if not inhibitted
# Only appears in CTF teamplay
# 
def func_ctf_wall(*qwp_extra):
    if engine.cvar('teamplay') & TEAM_CAPTURE_FLAG:
        qc.self.angles = Vector(0, 0, 0)
        qc.self.movetype = defs.MOVETYPE_PUSH #  so it doesn't get pushed by anything
        qc.self.solid = defs.SOLID_BSP
        qc.self.setmodel(qc.self.model)        
    else:
        qc.self.remove()
    

def qwp_reset_teamplay(*qwp_extra):
    global TEAM_DEFAULT_PENALTY
    global TEAM_STRICT_COOP
    global TEAM_COLOR1
    global TEAM_COLOR2
    global team1_lastspawn
    global team2_lastspawn
    global nextteamupdtime
    global last_flag_capture
    global last_capture_team
    global teamscr1
    global teamscr2
    global lastteamscrtime
    global TEAMSCRTIME
    global TEAM_HEALTH_PROTECT
    global TEAM_ARMOR_PROTECT
    global TEAM_ATTACKER_DAMAGE
    global TEAM_FRAG_PENALTY
    global TEAM_DEATH_PENALTY
    global TEAM_LOCK_COLORS
    global TEAM_STATIC_TEAMS
    global TEAM_DROP_ITEMS
    global TEAM_CAPTURE_FLAG
    global TEAM_DISABLE_GRAPPLE
    global TEAM_CAPTURE_CAPTURE_BONUS
    global TEAM_CAPTURE_TEAM_BONUS
    global TEAM_CAPTURE_RECOVERY_BONUS
    global TEAM_CAPTURE_FLAG_BONUS
    global TEAM_CAPTURE_FRAG_CARRIER_BONUS
    global TEAM_CAPTURE_FLAG_RETURN_TIME
    global TEAM_CAPTURE_CARRIER_DANGER_PROTECT_BONUS
    global TEAM_CAPTURE_CARRIER_PROTECT_BONUS
    global TEAM_CAPTURE_FLAG_DEFENSE_BONUS
    global TEAM_CAPTURE_RETURN_FLAG_ASSIST_BONUS
    global TEAM_CAPTURE_FRAG_CARRIER_ASSIST_BONUS
    global TEAM_CAPTURE_TARGET_PROTECT_RADIUS
    global TEAM_CAPTURE_ATTACKER_PROTECT_RADIUS
    global TEAM_CAPTURE_CARRIER_DANGER_PROTECT_TIMEOUT
    global TEAM_CAPTURE_CARRIER_FLAG_SINCE_TIMEOUT
    global TEAM_CAPTURE_FRAG_CARRIER_ASSIST_TIMEOUT
    global TEAM_CAPTURE_RETURN_FLAG_ASSIST_TIMEOUT
    global TEAM_CAPTURE_UPDATE_TIME
    global FLAG_AT_BASE
    global FLAG_CARRIED
    global FLAG_DROPPED
    
    TEAM_DEFAULT_PENALTY = 1
    TEAM_STRICT_COOP = 0
    TEAM_COLOR1 = 4
    TEAM_COLOR2 = 13
    team1_lastspawn = engine.world
    team2_lastspawn = engine.world
    nextteamupdtime = 0
    last_flag_capture = 0
    last_capture_team = 0
    teamscr1 = 0
    teamscr2 = 0
    lastteamscrtime = 0
    TEAMSCRTIME = 1
    TEAM_HEALTH_PROTECT = 1
    TEAM_ARMOR_PROTECT = 2
    TEAM_ATTACKER_DAMAGE = 4
    TEAM_FRAG_PENALTY = 8
    TEAM_DEATH_PENALTY = 16
    TEAM_LOCK_COLORS = 32
    TEAM_STATIC_TEAMS = 64
    TEAM_DROP_ITEMS = 128
    TEAM_CAPTURE_FLAG = 256
    TEAM_DISABLE_GRAPPLE = 2048
    TEAM_CAPTURE_CAPTURE_BONUS = 15
    TEAM_CAPTURE_TEAM_BONUS = 10
    TEAM_CAPTURE_RECOVERY_BONUS = 1
    TEAM_CAPTURE_FLAG_BONUS = 0
    TEAM_CAPTURE_FRAG_CARRIER_BONUS = 2
    TEAM_CAPTURE_FLAG_RETURN_TIME = 40
    TEAM_CAPTURE_CARRIER_DANGER_PROTECT_BONUS = 2
    TEAM_CAPTURE_CARRIER_PROTECT_BONUS = 1
    TEAM_CAPTURE_FLAG_DEFENSE_BONUS = 1
    TEAM_CAPTURE_RETURN_FLAG_ASSIST_BONUS = 1
    TEAM_CAPTURE_FRAG_CARRIER_ASSIST_BONUS = 2
    TEAM_CAPTURE_TARGET_PROTECT_RADIUS = 400
    TEAM_CAPTURE_ATTACKER_PROTECT_RADIUS = 400
    TEAM_CAPTURE_CARRIER_DANGER_PROTECT_TIMEOUT = 4
    TEAM_CAPTURE_CARRIER_FLAG_SINCE_TIMEOUT = 2
    TEAM_CAPTURE_FRAG_CARRIER_ASSIST_TIMEOUT = 6
    TEAM_CAPTURE_RETURN_FLAG_ASSIST_TIMEOUT = 4
    TEAM_CAPTURE_UPDATE_TIME = 120
    FLAG_AT_BASE = 0
    FLAG_CARRIED = 1
    FLAG_DROPPED = 2
