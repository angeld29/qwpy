###
### Generated by QuakeC -> Python translator
### Id: qc2python.py,v 1.5 2001/02/05 21:15:44 barryp Exp 
###
### 2001-02-17 Cleaned up translation (barryp)
###
from qwpython.qwsv import engine, Vector
from qwpython.qcsupport import qc

import defs
import subs
import random
import combat

stemp = engine.world
otemp = engine.world
s = engine.world
old = engine.world

def trigger_reactivate(*qwp_extra):
    qc.self.solid = defs.SOLID_TRIGGER
    
    
# =============================================================================
SPAWNFLAG_NOMESSAGE = 1
SPAWNFLAG_NOTOUCH = 1


#  the wait time has passed, so set back up for another activation
#
def multi_wait(*qwp_extra):
    if qc.self.max_health:
        qc.self.health = qc.self.max_health
        qc.self.takedamage = defs.DAMAGE_YES
        qc.self.solid = defs.SOLID_BBOX
        
    
#  the trigger was just touched/killed/used
#  self.enemy should be set to the activator so it can be held through a delay
#  so wait for the delay time before firing
#
def multi_trigger(*qwp_extra):
    if qc.self.nextthink > qc.time:
        return  #  allready been triggered
        
    if qc.self.classname == 'trigger_secret':
        if qc.self.enemy.classname != 'player':
            return 
        qc.found_secrets += 1
        qc.WriteByte(defs.MSG_ALL, defs.SVC_FOUNDSECRET)
        
    if qc.self.noise:
        qc.self.sound(defs.CHAN_VOICE, qc.self.noise, 1, defs.ATTN_NORM)
    #  don't trigger again until reset
    qc.self.takedamage = defs.DAMAGE_NO
    defs.activator = qc.self.enemy
    subs.SUB_UseTargets()
    if qc.self.wait > 0:
        qc.self.think = multi_wait
        qc.self.nextthink = qc.time + qc.self.wait       
    else:
        #  we can't just remove (self) here, because this is a touch function
        #  called wheil C code is looping through area links...
        qc.self.touch = subs.SUB_Null
        qc.self.nextthink = qc.time + 0.1
        qc.self.think = subs.SUB_Remove
        
    
def multi_killed(*qwp_extra):
    qc.self.enemy = defs.damage_attacker
    multi_trigger()
    

def multi_use(*qwp_extra):
    qc.self.enemy = defs.activator
    multi_trigger()
    

def multi_touch(*qwp_extra):
    if qc.other.classname != 'player':
        return 
    #  if the trigger has an angles field, check player's facing direction
    if qc.self.movedir != Vector(0, 0, 0):
        qc.makevectors(qc.other.angles)
        if qc.v_forward * qc.self.movedir < 0:
            return  #  not facing the right way
        
    qc.self.enemy = qc.other
    multi_trigger()
 
    
# QUAKED trigger_multiple (.5 .5 .5) ? notouch
# Variable sized repeatable trigger.  Must be targeted at one or more entities.  If "health" is set, the trigger must be killed to activate each time.
# If "delay" is set, the trigger waits some time after activating before firing.
# "wait" : Seconds between triggerings. (.2 default)
# If notouch is set, the trigger is only fired by other entities, not by touching.
# NOTOUCH has been obsoleted by trigger_relay!
# sounds
# 1)	secret
# 2)	beep beep
# 3)	large switch
# 4)
# set "message" to text string
# 
def trigger_multiple(*qwp_extra):
    if qc.self.sounds == 1:
        engine.precache_sound('misc/secret.wav')
        qc.self.noise = 'misc/secret.wav'        
    elif qc.self.sounds == 2:
        engine.precache_sound('misc/talk.wav')
        qc.self.noise = 'misc/talk.wav'        
    elif qc.self.sounds == 3:
        engine.precache_sound('misc/trigger1.wav')
        qc.self.noise = 'misc/trigger1.wav'
        
    if not qc.self.wait:
        qc.self.wait = 0.2
    qc.self.use = multi_use
    subs.InitTrigger()
    if qc.self.health:
        if qc.self.spawnflags & SPAWNFLAG_NOTOUCH:
            qc.objerror("health and notouch don't make sense\012")
        qc.self.max_health = qc.self.health
        qc.self.th_die = multi_killed
        qc.self.takedamage = defs.DAMAGE_YES
        qc.self.solid = defs.SOLID_BBOX
        qc.setorigin(qc.self, qc.self.origin) #  make sure it links into the world        
    else:
        if not (qc.self.spawnflags & SPAWNFLAG_NOTOUCH):
            qc.self.touch = multi_touch
            
            
# QUAKED trigger_once (.5 .5 .5) ? notouch
# Variable sized trigger. Triggers once, then removes itself.  You must set the key "target" to the name of another object in the level that has a matching
# "targetname".  If "health" is set, the trigger must be killed to activate.
# If notouch is set, the trigger is only fired by other entities, not by touching.
# if "killtarget" is set, any objects that have a matching "target" will be removed when the trigger is fired.
# if "angle" is set, the trigger will only fire when someone is facing the direction of the angle.  Use "360" for an angle of 0.
# sounds
# 1)	secret
# 2)	beep beep
# 3)	large switch
# 4)
# set "message" to text string
# 
def trigger_once(*qwp_extra):
    qc.self.wait = -1
    trigger_multiple()

    
# =============================================================================
# QUAKED trigger_relay (.5 .5 .5) (-8 -8 -8) (8 8 8)
# This fixed size trigger cannot be touched, it can only be fired by other events.  It can contain killtargets, targets, delays, and messages.
# 
def trigger_relay(*qwp_extra):
    qc.self.use = subs.SUB_UseTargets

    
# =============================================================================
# QUAKED trigger_secret (.5 .5 .5) ?
# secret counter trigger
# sounds
# 1)	secret
# 2)	beep beep
# 3)
# 4)
# set "message" to text string
# 
def trigger_secret(*qwp_extra):
    qc.total_secrets += 1
    qc.self.wait = -1
    if not qc.self.message:
        qc.self.message = 'You found a secret area!'
    if not qc.self.sounds:
        qc.self.sounds = 1
    if qc.self.sounds == 1:
        engine.precache_sound('misc/secret.wav')
        qc.self.noise = 'misc/secret.wav'
        
    elif qc.self.sounds == 2:
        engine.precache_sound('misc/talk.wav')
        qc.self.noise = 'misc/talk.wav'
        
    trigger_multiple()
    
# =============================================================================

def counter_use(*qwp_extra):
    qc.self.count -= 1
    if qc.self.count < 0:
        return 
    if qc.self.count != 0:
        if defs.activator.classname == 'player' and (qc.self.spawnflags & SPAWNFLAG_NOMESSAGE) == 0:
            if qc.self.count >= 4:
                qc.centerprint(defs.activator, 'There are more to go...')
            elif qc.self.count == 3:
                qc.centerprint(defs.activator, 'Only 3 more to go...')
            elif qc.self.count == 2:
                qc.centerprint(defs.activator, 'Only 2 more to go...')
            else:
                qc.centerprint(defs.activator, 'Only 1 more to go...')            
        return 
        
    if defs.activator.classname == 'player' and (qc.self.spawnflags & SPAWNFLAG_NOMESSAGE) == 0:
        qc.centerprint(defs.activator, 'Sequence completed!')
    qc.self.enemy = defs.activator
    multi_trigger()

    
# QUAKED trigger_counter (.5 .5 .5) ? nomessage
# Acts as an intermediary for an action that takes multiple inputs.
# 
# If nomessage is not set, t will print "1 more.. " etc when triggered and "sequence complete" when finished.
# 
# After the counter has been triggered "count" times (default 2), it will fire all of it's targets and remove itself.
# 
def trigger_counter(*qwp_extra):
    qc.self.wait = -1
    if not qc.self.count:
        qc.self.count = 2
    qc.self.use = counter_use

    
# 
# ==============================================================================
# 
# TELEPORT TRIGGERS
# 
# ==============================================================================
# 
PLAYER_ONLY = 1
SILENT = 2

teleport_sound_list = ('misc/r_tele1.wav', 
                       'misc/r_tele2.wav',
                       'misc/r_tele3.wav',
                       'misc/r_tele4.wav',
                       'misc/r_tele5.wav')
                       
def play_teleport(*qwp_extra):
    qc.self.sound(defs.CHAN_VOICE, random.choice(teleport_sound_list), 1, defs.ATTN_NORM)
    qc.self.remove()
    

def spawn_tfog(org, *qwp_extra):
    global s
    s = qc.spawn()
    s.origin = org
    s.nextthink = qc.time + 0.2
    s.think = play_teleport
    qc.WriteByte(defs.MSG_MULTICAST, defs.SVC_TEMPENTITY)
    qc.WriteByte(defs.MSG_MULTICAST, defs.TE_TELEPORT)
    qc.WriteCoord(defs.MSG_MULTICAST, org.x)
    qc.WriteCoord(defs.MSG_MULTICAST, org.y)
    qc.WriteCoord(defs.MSG_MULTICAST, org.z)
    engine.multicast(org, defs.MULTICAST_PHS)
    

def tdeath_touch(*qwp_extra):
    if qc.other == qc.self.owner:
        return 
    #  frag anyone who teleports in on top of an invincible player
    if qc.other.classname == 'player':
        if qc.other.invincible_finished > qc.time:
            qc.self.classname = 'teledeath2'
        if qc.self.owner.classname != 'player':
            #  other monsters explode themselves
            combat.T_Damage(qc.self.owner, qc.self, qc.self, 50000)
            return                     
    if qc.other.health:
        combat.T_Damage(qc.other, qc.self, qc.self, 50000)        
    

def spawn_tdeath(org, death_owner, *qwp_extra):
    death = qc.spawn()
    death.classname = 'teledeath'
    death.movetype = defs.MOVETYPE_NONE
    death.solid = defs.SOLID_TRIGGER
    death.angles = Vector(0, 0, 0)
    qc.setsize(death, death_owner.mins - Vector(1, 1, 1), death_owner.maxs + Vector(1, 1, 1))
    qc.setorigin(death, org)
    death.touch = tdeath_touch
    death.nextthink = qc.time + 0.1
    death.think = subs.SUB_Remove
    death.owner = death_owner
    qc.force_retouch = 2 #  make sure even still objects get hit
    

def teleport_touch(*qwp_extra):
    if qc.self.targetname:
        if qc.self.nextthink < qc.time:
            return  #  not fired yet
                    
    if qc.self.spawnflags & PLAYER_ONLY:
        if qc.other.classname != 'player':
            return 
        
    #  only teleport living creatures
    if qc.other.health <= 0 or qc.other.solid != defs.SOLID_SLIDEBOX:
        return 
        
    subs.SUB_UseTargets()
    
    #  put a tfog where the player was
    spawn_tfog(qc.other.origin)
    t = qc.find(qc.world, 'targetname', qc.self.target)
    if not t:
        qc.objerror("couldn't find target")
        
    #  spawn a tfog flash in front of the destination
    qc.makevectors(t.mangle)
    org = t.origin + 32 * qc.v_forward
    spawn_tfog(org)
    spawn_tdeath(t.origin, qc.other)
    
    #  move the player and lock him down for a little while
    if not qc.other.health:
        qc.other.origin = t.origin
        qc.other.velocity = (qc.v_forward * qc.other.velocity.x) + (qc.v_forward * qc.other.velocity.y)
        return 
        
    qc.setorigin(qc.other, t.origin)
    qc.other.angles = t.mangle
    if qc.other.classname == 'player':
        #  Teleporting - detach hook (wedge)
        if qc.other.weapon == defs.IT_GRAPPLE and qc.other.hook_out:
            qc.other.sound(defs.CHAN_WEAPON, 'weapons/bounce2.wav', 1, defs.ATTN_NORM)
            qc.other.on_hook = defs.FALSE
            qc.other.hook_out = defs.FALSE
            qc.other.weaponframe = 0
            qc.other.attack_finished = qc.time + 0.75 #  avoid instant rehook
            
        qc.other.fixangle = 1 #  turn this way immediately
        qc.other.teleport_time = qc.time + 0.7
        if qc.other.flags & defs.FL_ONGROUND:
            qc.other.flags -= defs.FL_ONGROUND
        qc.other.velocity = qc.v_forward * 300
        
    qc.other.flags -= qc.other.flags & defs.FL_ONGROUND
    
    
# QUAKED info_teleport_destination (.5 .5 .5) (-8 -8 -8) (8 8 32)
# This is the destination marker for a teleporter.  It should have a "targetname" field with the same value as a teleporter's "target" field.
# 
def info_teleport_destination(*qwp_extra):
    #  this does nothing, just serves as a target spot
    qc.self.mangle = qc.self.angles
    qc.self.angles = Vector(0, 0, 0)
    qc.self.model = None
    qc.self.origin += Vector(0, 0, 27)
    if not qc.self.targetname:
        qc.objerror('no targetname')
    

def teleport_use(*qwp_extra):
    qc.self.nextthink = qc.time + 0.2
    qc.force_retouch = 2 #  make sure even still objects get hit
    qc.self.think = subs.SUB_Null
    
    
# QUAKED trigger_teleport (.5 .5 .5) ? PLAYER_ONLY SILENT
# Any object touching this will be transported to the corresponding info_teleport_destination entity. You must set the "target" field, and create an object with a "targetname" field that matches.
# 
# If the trigger_teleport has a targetname, it will only teleport entities when it has been fired.
# 
def trigger_teleport(*qwp_extra):
    subs.InitTrigger()
    qc.self.touch = teleport_touch
    #  find the destination 
    if not qc.self.target:
        qc.objerror('no target')
    qc.self.use = teleport_use
    if not (qc.self.spawnflags & SILENT):
        engine.precache_sound('ambience/hum1.wav')
        o = (qc.self.mins + qc.self.maxs) * 0.5
        engine.ambientsound(o, 'ambience/hum1.wav', 0.5, defs.ATTN_STATIC)
        
    
# 
# ==============================================================================
# 
# trigger_setskill
# 
# ==============================================================================
# 
# QUAKED trigger_setskill (.5 .5 .5) ?
# sets skill level to the value of "message".
# Only used on start map.
# 
def trigger_setskill(*qwp_extra):
    qc.self.remove()

    
# 
# ==============================================================================
# 
# ONLY REGISTERED TRIGGERS
# 
# ==============================================================================
# 
def trigger_onlyregistered_touch(*qwp_extra):
    if qc.other.classname != 'player':
        return 
    if qc.self.attack_finished > qc.time:
        return 
    qc.self.attack_finished = qc.time + 2
    if engine.cvar('registered'):
        qc.self.message = None
        subs.SUB_UseTargets()
        qc.self.remove()        
    else:
        if qc.self.message != None:
            qc.centerprint(qc.other, qc.self.message)
            qc.other.sound(defs.CHAN_BODY, 'misc/talk.wav', 1, defs.ATTN_NORM)
                    
    
# QUAKED trigger_onlyregistered (.5 .5 .5) ?
# Only fires if playing the registered version, otherwise prints the message
# 
def trigger_onlyregistered(*qwp_extra):
    engine.precache_sound('misc/talk.wav')
    subs.InitTrigger()
    qc.self.touch = trigger_onlyregistered_touch

    
# ============================================================================

def hurt_on(*qwp_extra):
    qc.self.solid = defs.SOLID_TRIGGER
    qc.self.nextthink = -1
    

def hurt_touch(*qwp_extra):
    if qc.other.takedamage:
        qc.self.solid = defs.SOLID_NOT
        combat.T_Damage(qc.other, qc.self, qc.self, qc.self.dmg)
        qc.self.think = hurt_on
        qc.self.nextthink = qc.time + 1        
    return 

    
# QUAKED trigger_hurt (.5 .5 .5) ?
# Any object touching this will be hurt
# set dmg to damage amount
# defalt dmg = 5
# 
def trigger_hurt(*qwp_extra):
    subs.InitTrigger()
    qc.self.touch = hurt_touch
    if not qc.self.dmg:
        qc.self.dmg = 5

    
# ============================================================================

PUSH_ONCE = 1

def trigger_push_touch(*qwp_extra):
    if qc.other.classname == 'grenade':
        qc.other.velocity = qc.self.speed * qc.self.movedir * 10
    elif qc.other.health > 0:
        qc.other.velocity = qc.self.speed * qc.self.movedir * 10
        if qc.other.classname == 'player':
            if qc.other.fly_sound < qc.time:
                qc.other.fly_sound = qc.time + 1.5
                qc.other.sound(defs.CHAN_AUTO, 'ambience/windfly.wav', 1, defs.ATTN_NORM)                                    

    if qc.self.spawnflags & PUSH_ONCE:
        qc.self.remove()

    
# QUAKED trigger_push (.5 .5 .5) ? PUSH_ONCE
# Pushes the player
# 
def trigger_push(*qwp_extra):
    subs.InitTrigger()
    engine.precache_sound('ambience/windfly.wav')
    qc.self.touch = trigger_push_touch
    if not qc.self.speed:
        qc.self.speed = 1000

    
# ============================================================================

def trigger_monsterjump_touch(*qwp_extra):
    if qc.other.flags & (defs.FL_MONSTER | defs.FL_FLY | defs.FL_SWIM) != defs.FL_MONSTER:
        return 
    #  set XY even if not on ground, so the jump will clear lips
    qc.other.velocity %= Vector(qc.self.movedir.x * qc.self.speed, qc.self.movedir.y * qc.self.speed, None)
    if not (qc.other.flags & defs.FL_ONGROUND):
        return 
    qc.other.flags -= defs.FL_ONGROUND
    qc.other.velocity %= Vector(None, None, qc.self.height)

    
# QUAKED trigger_monsterjump (.5 .5 .5) ?
# Walking monsters that touch this will jump in the direction of the trigger's angle
# "speed" default to 200, the speed thrown forward
# "height" default to 200, the speed thrown upwards
# 
def trigger_monsterjump(*qwp_extra):
    if not qc.self.speed:
        qc.self.speed = 200
    if not qc.self.height:
        qc.self.height = 200
    if qc.self.angles == Vector(0, 0, 0):
        qc.self.angles = Vector(0, 360, 0)
    subs.InitTrigger()
    qc.self.touch = trigger_monsterjump_touch
    

def qwp_reset_triggers(*qwp_extra):
    global stemp
    global otemp
    global s
    global old
    global SPAWNFLAG_NOMESSAGE
    global SPAWNFLAG_NOTOUCH
    global PLAYER_ONLY
    global SILENT
    global PUSH_ONCE
    
    stemp = engine.world
    otemp = engine.world
    s = engine.world
    old = engine.world
    SPAWNFLAG_NOMESSAGE = 1
    SPAWNFLAG_NOTOUCH = 1
    PLAYER_ONLY = 1
    SILENT = 2
    PUSH_ONCE = 1
